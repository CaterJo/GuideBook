
#Thread

(1)Process&Program

##프로그램
=>실행상태가 아닌 그냥 설치만되어있는 하드디스크에 저장된 상태.


##프로세스
=>실행중인 프로그램.
=>주기억장치에 프로그램이 로드된 상태.
=>모든 리소스는 주기억장치에 올라와있어야 접근이 가능하다.
=>프로세스는 여러개 실행될수있다(멀티프로세스)
=>도스시절엔 싱글프로세스였다(오로지 하나의 프로세스)
=>우리는 하나의 프로세스만 생각합시다.
=>하나의 프로세스에서 하나의 작업만한다면.. 얼마나 불편할까
=>멀티쓰레드 하나으 프로세스에서 하나이상의 작업을 하는것..

	**쓰레드
	=>하나의 작업단위.
	=>어디서부터 어디까지가 한 단위(쓰레드로할꺼야)
	=>ex)저장,편집,인쇄 등등.. 하나의 작업단위.
	

	**멀티 프로세서
	=>CPU가 여러개 있다는것.(프로세스 처리장치 CPU가 여러개 있다는것)


	**하나의 CPU로 어떻게 멀티테스킹을 할 수 있었을까?
	=>자체적인 스케줄에 의해서 쪼개서 사용한다
	=>빨리해서 동시에 하는것처럼 연출되는것 뿐이다.



13.Thread
(1)Process&Program
	-멀티프로세스,멀티프로세서,멀티 쓰레드.

(2)하나의 프로세스에서 실행하는 작업단위.
(3)모든 프로세스는 반드시 1개의 스레드를 포함하고 있다.
   =>메인메서드.(메인쓰레드)
(4)구현방식
	1)Thread클래스 상속.
	-단일상속.
	2)Runnable 인터페이스 상속.
	-다중상속을 해야하는경우(인터페이스)

(5)Lifecycle(생명주기.)

=>그림을 그려봅시다.



#메인쓰레드가 하는일은 



*자식쓰레드
=>메인쓰레드를 제외한 모든쓰레드
=>메인쓰레데에 의해서 생긴 쓰레드
=>Run()  (자식쓰레드가 해야할일을 적어둔다)



*콜백메서드
=>시스템이 호출한다(우리가 호출하는것이 아니라)
=>우리가 직접명시하고 호출하는것이 아니라 시스템이 불러다 쓴다.


-쓰레드를 상속받은 클래스의 인스턴스만 쓰레드다.



#라이프 사이클.

1.run
-스레드가 실질적으로 실행된다.


2.start
-스레드가 run으로 이동되기 전에 start에서 대기한다.


3.종료
-작업을 마친 스레드가 이동하여 사라진다.



4.suspend -디프리케이티드
-깨우는 명령어를 넘길때까지 쉰다.(휴게실)

*resume	-디프리케이티드


5.sleep
-타이머 휴게실
-정해둔 시간만큼만 스레드가 멈췄다가 다시 실행된다.



6.지연(delay)
-지가 알아서 쉬러갔다가
-지가 알아서 다시 실행된다.
-자동화기때문에 사용자가 컨트롤할만한게 없다.

->하드웨어를 읽을때 잠시 지연되는것
->이때 잠시 멈췄다가 다시 실행된다.
->이게 지연...



#강제종료
-stop()
-interrupt()
-직접제어.




*동기화(synchronize)
->똑같이 맞춰주는것.
->동시접속을 막아야한다(동시처리가 안된다.)
->한번에 일을 한가지씩한다.
->정말 필요한곳에서만 동기화를 써야한다.

=>동기화 알고리즘
 ->세마포어
 ->뮤텍스


(6)동기화 :synchronized
	1)synchronized 반환형 메서드(){...}
	2)synchrozized(공유객체){		//어떤상황에서 사용하는지.
		코드
		...
	}

	*weit, notify에 대한 예..






1.사용법정리.
지니야 심심해
지니야 시끄러
지니야 안들려
지니야 잘가

-랜덤확률로 전원이 꺼진다.
-볼륨 80이상에서 지니가 10번 경고한다.

'주인님의 청각이 걱정됩니다 ㅠㅠ'

장기적인 소스 유지보수.



쉽게 생각해서

String으로 어떤 값을 저장한다. St
키보드값을 해당 문자열을 입력했을 때  St와 같다면 특정 메세지지를 출력하는 프로그램을 짜본다.


