

# 상속

1) 상속되지 않는것.
	- 생성자 : 상속을 받을땐 생성자의 의미가 없다 
	- private :실질적으로 상속은되지만 호출가능..
	

2) 생성자 호출

~~~ java
super();
~~~
- 상속받을수는 없지만 호출 할 수 있다.
- 반드시 생성자 안에서만 호출이 가능하다.(일반 메서드에서 사용할수 없다.) 
- 반드시 첫줄에서 사용해야한다. (순서가 중요하다) 
- super.변수,super.메서드() 
- 즉 supuer는 부모의 주소를 의미한다.
- 참조변수 읽기전용!	(this와 비슷하다) 
- this는 자기자신의 주소, super는 supercalss의 주소.


3)  생성자의 호출순서.
	- sub class의 생성자를 생성하면 supercalss 의 생성자가 함께생긴다.
	- 이런 이유때문에 기본생성자의 명시적 선언이 필요함.


4) 상속(inheritance) 은 확장(extention) 의 개념이다.
	- 추가적인 성능개선이 필요하기때문에 상속이 사용된다.
	-  extends Super class (super class를 확장해라) 



5) 클래스에서는 단일상속만 지원한다.

	*상속
	1) 단일상속
		- 하나의 super class로부터 가지치기로 뻗어나가는 tree형태

	2) 다중상속
		- 상속을 받는 super클래스가 여러개 역트리의 형태로 하나의 subclass로 귀결된다.
		- 이런 개념을 선택한것이 C++이다.
		- 겁나 피봤다.(what is the problem?) 
			1)  같은기능이 중복되서 낭비가된다. 최초설게부터 완벽하게 해야한다.
			2)  기능파악이 굉장히 힘들어진다. (수많은 super클래스들..) 



		## 상속설계
		*super class는 모든 subclass에 공통 기능만을 부여한다. (교집합) 
		- 베이스를 기반으로 점진적 확장이 되도록!


			**상속을 비유하고 가장 쉬운 예는 '자동차'
			가장 공통적인 베직한 기능은 뭐가 있을까? (변수와 메서드의 관점으로) 

			1차(자동차) 

			변수(상태) 
			- 휠,제조사,엔진
			메서드
			- (제동,속도) 

			2차(트럭) 
			변수
			- 몇톤?

			메서드
			- 

			3차(컨테이너차량) 
			변수 -  소유자.
			메서드 -  ....

			it is possible 체계적인 extention.



6) spuer와 sub의 참조관계 
	1) 서로다른 클래스는 참조할 수없다.(강제 형변환을 해도 안된다) 
  
 	2) Spuer는 sub를 참조할수 있다. (상속관계에서) 
		- sub의 주소값을 저장할 수 있다.
		(sub는 spuer의 데이터를 모두 포함고하고 있다) 
		- 단.. spuer로 부터 상속받은것만 참조가 가능하다.
		- 내가 준것만 확인할수 있다 ㅋㅋ 

	 3) sub는 spuer를 참조할수 없다.
		- spuer는 sub의 데이터를 모두 포괄하지 않는다.(집합관계를 떠올릴것) 
		- 캐스팅을 했을때 문법적 오류는 없지만 실행이 안된다 결론 안된다.
		- 부모가 자식을 참조해야하는경우

	4) 용도
		1. 인스턴스가 결정되지 않았을때
			- 주소를 잃어버리지 않기 위한 임시적인 방편으로 사용가능하다.
			- 상속관게에 의한 참조특성은 참조값의 임시적 보관의 용도로 사용한다.
			- 확장된 기능을 사용하려는게 아니라면 굳이 이렇게 할 의무는 없다.
		~~~ java
		/*
		O,A,B의 클래스가 있다고 하자.
		O는 A,B의 spuerClass이다
		*/
		A a1 = new A() ;
		
		//아직 어떤 인스턴스를 대입해야할지 모름를 때
		A a2 = ?;
		
		//이런 경우가 생겼을때 다른 클래스를 포괄할 수 있는 Spuer Class를 선언하면 A, B 인스턴스 모두 사용 선언 가능하다.
		O ob1 = ?
		//그런데 이런 상속의 리밋트를 어떻게 해결한것인가? 
		//(추가기능에 접근하기위해선) 
		//이런식으로 다시 넘겨받는다. (이때는 캐스팅이 필요하다) 
		B b1 = (B)  ob1;
		
		~~~

		2) 자식인스턴스를 배열로 관리하기 위해서
		~~~ java
		A a = new A();
		B c = new B();
		C c = new C();
		//(서로다른 클래스라서 묶을수없다...) 
		//(이때 spuer 클래스로 묶는게 가능하다) 

		O ob= {a,b,c new D() };
		ob[0],ob[1]
		~~~



7.  OverWriting. (오버라이딩)
	- 재정의
	- 내 입맛에 맞게 편집하는것
	- 메모리 절약이 가능하다
	- 포인트는 부모로부터 상속받은 매서드 재정의하는것.
	- 상속받은 메소드를 재정의하기때문에 상속에서만 사용가능하다.
	
8.  OverLoading (오버로딩)
	- 중복정의
	- 기존의 메서드의 내용을 편집해서 사용한다.
	- 신규 메서드 생성으로인한 메모리의 추가적인 사용을 막을 수 있다.

