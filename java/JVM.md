# 자바가상머신 (JVM)
- 자바 바이트 코드(class file)를 실행할 수 있는 주체다.
- 운영체계가 이해할 수 있는 기계어로 바꿔 실행한느 역할.
- CPU나 운영체제(플랫폼)의 종류와 무관하게 실행이 가능하다. 



## JVM 구성
![](/resource/img/java/jvmStructure.png)



### 1. Class Loader

자바에서 소스를 작성하면 Person.java 처럼 .java파일이 생성된다.
.java 소스를 자바컴파일러가 컴파일하면 Person.class 같은 .class파일(바이트 코드)이 생성된다.  

이렇게 생성된 클래스파일들을 엮어서 JVM이 운영체제로부터 할당받은 메모리영역인 Runtime Data Area로 적재하는 역할을 Class Loader가 한다. 
- 런타임중 발생한 클래스를 동적으로 힙메모리에 로딩해주는 역할





### 2. Execution Engine

![](/resource/img/java/JITcompiler.png)  
Class Loader에 의해 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.  
바이트코드를 기계어로 바꾸는 방식에는 두가지 방식이 있다.<br/>

1. 인터프린터(InterPrinter):
    - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다.
    - 하나하나 해석은 빠르지만 전체적인 실행속도는 느리다.
    - JVM안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다.
2. JIT Compiler
    - 인터프린터의 단점을 보완하기 위해 도입된 방식
    - 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식
    - 하나씩 인터프리팅하여 실행하는것이 아니라 바이트 코드 전체가 컴파일 도니 네이티브 코드를 실행 하기 때문에 전체적인 실행속도는 인터프리팅 보다 빠르다.
    - JSI compiler는 Intermediate Representation으로 변환하여 최적화를 수행하고 그 다음에 네이티브 코드로 변환한다.

네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 캐시에서 바로 꺼내어 실행하기 때문에 빠르다.  
 하지만 JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 하나씩 인터프리팅 하는 것보다 훨씬 오래 걸린다.  
 때문에 JITcomplier를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 호출되고 실행되는지 체크하고, 일정 기준이 넘었을 때에만 JIT compiler를 통해 컴파일 하여 네이티브 코드를 생성한다.


### 3. Garbage Collector

Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.  
GC가 역할을 하는 시간은 정확히 언제인지를 알 수 없다. (참조가 없어지자마자 해제되는 것을 보장하지 않음)  
또 다른 특징은 GC가 수행되는 동안 GarbageCollection을 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지된다.  

특히 Full GC가 일어나서 수 초간 모든 쓰레드가 정지한다면 장애로 이어지는 치명적인 문제가 생길 수 있는 것이다. (GC와 관련된 내용은 아래 Heap영역 메모리를 설명할 때 더 자세히 알아본다.)  




### 4. RunTime Data Area

JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.  

이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다.

Method Area, Stack Area는 모든 쓰레드가 공유한다.  
PC Register, Native Method Stack는 쓰레가 개별적으로 생성된다.


![](/resource/img/java/javaRuntimeMemoryArea.png)  


#### 4.1  Method area (메소드 영역)

- 런타임시 생성된 모든 스레드가 공유하는 영역.
- JVM이 기본적으로 할당받는 메소드 영역의 메모리 사이즈는 일정하게 정해져 있다.
- 이 범위를 벗어나면 OutOfMemory 에러가 발생한다.<br/>
클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다.

**Runtime Constant Poll**
JVM 동작에서 가장 핵심적인 역할을 수행하는 곳으로 JVM명세에서도 따로 중요하게 기술한다.
  각 클래스와 인터페이스의 상수 뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블로 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.

#### 4.2 Heap area (힙 영역)

- new 키워드로 생성된 인스턴스와 객체를 저장하는 공간으로 Garbage Collection 대상이다.
- JVM 선능 등의 이슈에서 가장 많이 언급되는 영역
- 힙 구성 방식이나 가비지 컬렉션 방법은 JVM 벤더들의 재량이다.

#### 4.3 Stack area (스택 영역)

- 메소드가 호출되면 Stack Frame이라는 자료구조가 생성된다.
- Stack Frame은 실행 순서에 따라 스택 동작을 수행하다가, 모든 동작이 완료되면 메모리에서 사라진다.
- 예외발생시 printtStackTace()메서드로 보여주는 Stack Trace의 각 라인 하나가 스택 프레임을 표현한다.  


지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.  
int a = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리 공간a를 생성하고 그 메모리 영역에 값이 10을 할당한다.  
즉, 스택에 메모리에 이름이 a라고 붙여주고 값이 10인 메모리 공간을 만든다.  

클래스 Person p = new Person(); 이라는 소스를 작성했다면 Person p는 스택 영역에 생성되고 new로 생성된 Person 클래스의 인스턴스는 힙 영역에 생성된다.  

그리고 스택영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있다.  
즉, 스택 영역에 생성된 p가 힙 영역에 생성된 객체를 가리키고(참조하고) 있는 것이다.  
메소드를 호출할 때마다 개별적으로 스택이 생성된다.

#### 4.4 PC Register (PC 레지스터)

Thread(쓰레드)가 생성될 때마다 생성되는 영역으로   
Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다.  
이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 한다.  
각 스레드마다 하나씩 존재한다.


####  4.5 Native method stack

자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다.  
JNI(Java Navtive Interface)를 통해 호출하는 C/C++등의 코드를 수행하기 위한 스택으로 각 언어에 맞게 생성된다.





## HeapMemory And GarbageCollector

힙 영역은 GC의 주요 대상이다.   
힙 영역은 우선 5개의 영역(eden, survivor1, survivor2, old, permanent)으로 나뉜다.  
(survivor영역의 숫자는 의미없고 두 개로 나뉜다는 것이 중요하다)  
힙 영역을 굳이 5개로 나눈 이유는 효율적으로 GC가 일어나게 하기 위함이다.  
자세한 것은 GC가 일어나는 프로세스를 보면서 설명한다.  

GC는 Minor GC와 Major GC로 나뉜다.  

### 1.Minor GC : New 영역에서 일어나는 GC

1. 최초에 객체가 생성되면 Eden영역에 생성된다.
2. Eden영역에 객체가 가득차게 되면 첫 번째 CG가 일어난다.
3. survivor1 영역에 Eden영역의 메모리를 그대로 복사된다. 그리고 survivor1 영역을 제외한 다른 영역의 객체를 제거한다.
4. Eden영역 survivor1영역 모두 가득차게된다면, Eden영역에 생성된 객체와 survivor1영역에 생성된 객체 중에 참조되고 있는 객체가 있는지 검사한다.
5. 참조 되고있지 않은 객체는 내버려두고 참조되고 있는 객체만 survivor2영역에 복사한다.
6. survivor2영역을 제외한 다른 영역의 객체들을 제거한다.
7. 위의 과정중에 일정 횟수이상 참조되고 있는 객체들을 survivor2에서 Old영역으로 이동시킨다.

- 위 과정을 계속 반복한다
- survivor2영역까지 꽉차기 전에 계속해서 Old로 비움


### Major GC(Full GC) : Old 영역에서 일어나는 GC

1. Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.
2. 참조되지 않은 객체들을 모아 한 번에 제거한다.
- Minor GC보다 시간이 훨씬 많이 걸리고 실행중에 GC를 제외한 모든 쓰레드가 중지한다.

* Major GC가 일어나면,

1. Old영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다.

2. 그러면서 Heap 메모리 영역에 중간중간 구멍(제거되고 빈 메모리 공간)이 생기는데 이 부분을 없애기 위해 재구성을 하게 된다. (디스크 조각모음처럼 조각난 메모리를 정리함)

3. 따라서 메모리를 옮기고 있는데 다른 쓰레드가 메모리를 사용해버리면 안되기 때문에 모든 쓰레드가 정지하게 되는 것이다.





## 클래스 로더.
1. 계층구주조
2. 위임모델
3. 가시성 제한
4. 언로드(unload)불가.
5. 이름공간(Name Space)


### 1. 클래스로더_계층구조
![](/resource/img/java/classLoader.png)  


### 부트스크랩 클래스 로더 (Bootstrap Class Loader)
- 최상위 클래스로더로 유일하게 JAVA가 아니라 네이티브 코드로 구현되어있다.
- JVM이 실행될 때 같이 메모리에 올라간다.
- Object 클래스를 비롯하여 JAVA API들을 로드한다.

### 익스텐션 클래스 로더(Extention Class Laoder)
- 기본 JAVA API를 제외한 확장 클래스들을 로드한다.

### 시스템 클래스 로더(System Class Loader)
- 부트스트랩과 익스텐션 클래스로더가 JVM 자체의 구성요소들을 로드한다면, 시스템 클래스 로더는 어플리케이션의 클래스들을 로드한다.
- 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드한다.

### 사용자 정의 클래스 로더(User-Defined Class Loader)
- 어플리케이션 사용자가 직접 코드상에서 생성하여 사용하는 클래스 로더

was같은 프레임 워크는 웹 어플리케이션, 엔터프라이즈 어플리케이션이 서로 독립적으로 동작하게 하기 위해서 사용자 정의 클래스 로더들을 사용하여 클래스 로더의 위임모델을 통해 어플리케이션의 독립성을 보장한다.
따라서 was의 클래스 로더 구조는 was벤더마다 조금식 다른 형태의 게층 구조를 사용하고 있다고 한다.


### 2. 클래스로더_위임모델
![](/resource/img/java/classLoader2.png)  
위임모델이란 처음 바이트코드를 넘겨받은 클래스 로더가 필요한 클래스를 로드할 때 혹인 실행엔젠에서 명령어 단위로 바이트 코드를 실행하다가 처음으로 참조하는 클래스에 대해 클래스 로더에게 로드를 요청할 때 로드를 요청받는 클래스 로더는 다음 순서대로 요청받는 클래스가 있는지 확인한다.

1. 클래스 로더 캐시
2. 상위클래스 로더
3. 자기 자신

이전에 로드된 클래스인지 클래스 로더 캐시를 확인하고 없으면 상위 클래스 로더를 하나씩 거슬러 올라가며 확인하는데 이 때 중요한 점은 올라가는 도중에 클래스를 발견하더라도 부트스트랩 클래스 로더까지 확인을 해서 부트스트랩 클래스로더에도 해당 클래스가 존재하면 부트스트랩 클래스 로더에 있는 클래스를 로드한다는 점이다.

예를 들어 요청받은 클래스가 시스템 클래스 로더에 존재하여도 부트스트랩 클래스 로더까지 확인을 하고 부트스트랩에도 해당 클래스가 존재하면 부트스트랩에 있는 클래스를 로드하게 된다는 거다.

이러한 특성으로 아키텍쳐는 JVM에 대한 지식이 필요하다.<br/>
마지막으로 부트스트랩 클래스 로더에도 해당 클스가 없으면 로드를 요청받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾는것으로 마무리 된다.
(파일 시스템에서도 찾지 못하면 Not Found Exception이 떨어진다.)


### 3.가시성 제한.
클래스 로더가 클래스 로드를 요청받았을 때 위임모4델에 의해서 클래스 로더 캐시를 확인하고 없으면 상위 클래스 로더를 확인하는데 이 때 하위 클래스 로더에 있는 클래스는 확인이 불가능한 특성이 바로 가시성 제한이다.


### 언로드(Unload)불가
클래스를 로드하는 것은 가능하지만 반대로 언로드(Unload)하는 것은 불가능하다는 특성..


### Name Space
클래스 로더들이 가지고 있는 공간으로써 로드된 클래스를 보관하는 공간이다.
클래스를 로드할 때 위임 모델을 통해서 상위 클래스 로더들을 확인하는데 그 때 확인하는 공간이 바로 네임스페이스이다. 
네임스페이스에 보관되는 기준은 FQCN(Full Qualified Class Name)을 기준으로 보관되는데 FQCN이란 패키지명까지 포관되어있는 식별자를 의미한다.

각각 클래스 로더가 네임스페이스를 가지고 있기 때문에 패치키명까지 같은 즉, FQCN이 같은 클래스라도 네임스페이스가 다르면 다른 클래스로 간주한다.(다른 클래스 로더가 로드한 클래스이면)
이 특성을 이용하면 언로드를 대신해서 로드한 클래스 로더를 제거하면 마치 언로드한 것과 같은 효과를 볼 수 있다.



### 클래스 로드
![](/resource/img/java/classLoader3.png)  


1. 로드 : 클래스 파일을 가져와서 JVM 메모리에 로드한다.
2. 검증 : 클래스 로드 전 과정 중에서 가장 복잡하고 시간이 많이 걸리는 과정으로 읽어들인 클래스가 가바 언어명세 (JAVA Language Sepcification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.

3. 준비 : 클래스가 필요로하는 메모리를 할다한다. 필요한 메모리란 클래스에서 정의된 필드, 메서드 인터페이스들을 나타내는 데이터 구조를 말한다.

4. 분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.

5. 초기화. 클래스 변수들을 적절한 값으로 초기화한다.( ex.static 필드들을 설정된 값으로 초기화하는 작업.)
