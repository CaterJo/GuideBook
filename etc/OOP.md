# Object-Oriented Programming


## intro
객체 지향 프로그래밍은 컴퓨터 프로그램을 객체들의 모임으로 파악하고자 하는 프로그래밍 패러다임 중 하나다.  


## 장점
객체지향 프로글밍의 가장 중요한 특성은 강한 응집력과 약한 결합력을 지향한다는 것이다.  

**응집력(cohesion)**  
프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다.


**결합력(coupling)**  
프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도. 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.  


## 구성요소  
- 클래스  
같은 종류의 짐단에 속하는 속성과 행위를 정의한 것.  다른 클래스와 독립적으로 디자인해야한다.  

- 객체  
클래스의 인스턴스 상위 클래스의 속성을 가지고 있으면서 개별적인 특성과 행위도 가지고 있다.  

- 메서드  
클래스로부터 생성된 객체를 사용하는 방법. 객체의 속성을 조작하는 데 사용된다. 


## 특성

### 캡슐화
캡슐화는 객체 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다. 
```js
const Monster = (function(){

	let count = 0;
	const pool = [];

	class Monster {
		constructor(name){
			this.name = name;

			pool.push(this)
		}
		count++;
		this.level = 1;
		levelUp(){
			this.level++;
			console.log('level Up!')
		}
	}

	return Monster
})()

let m1 = new Moster('name');
```










## 1. SOLID
객체지향 설계 원칙



### 1. SRP(Single Responsibility)
단일책임의 원칙

클래스는 단 한개의 책임을 가져야한다.  
dto의 경우 Text에 대한 DTO, img에 대한 DTO 가 나뉘어져있어야한다.  
이것이 통일되어있는경우 1개의 클래스가 2개의 책임을 갖는다.  



### 2. OCP(Open Close Principle)
 개방-폐쇄의 원칙  
 확장에는 열려있고 수정에는 닫혀있어야한다.
 
1. 확장에 대해서는 Open

	요구사항이 변경 될 때, 새로운 동작이나 기능을 추가 할 수 있어야한다.

2. 변경에 대해 닫혀 있다.
	
	기능 확장으로 인해서 그 모듈의 코드가 변경되는 일이 일어나는것은 아니다.  
	즉, 클래스를 수정하지 않으면서 확장이 가능해야한다.



### 3. LSP(The Liskov Substitution Principle)
리스코프 치환 원칙  
부모 클래스에서 자식 클래스 객체를 대입해 사용해도 프로그램은 정상적으로 동작해야한다.  
	자식과 부모 클래스 사이에 행위에는 일관성이 있어야한다.  
개적으로 상속관계에 있는 것처럼 보일지 몰라도 실제 구현에서는 상속관계가 아닐 수 있다.  

### 이 원칙에 위배되면...
- 자식클래스 객체를 파라미터로 전달 했을때 프로그램이 정상적으로 동작하지 않는다.
- 향후 기능을 변경하거나 확장시 코드를 수정해야한다.

### 4. ISP(Interface Segregation Principle)
- 인터페이스 분리의 원칙.

클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말야아한다.  
하나의 인터페이스로 모든것을 처리하는 것보다는 작은 여러개의 인터페이스를 처리하는것이 낫다.  


### 5. DIP(Dependency Inversion Principle)
 - 의존 역전의 원칙.

상위 모듈이 하위 모듈의 구현이 의존해서는 안된다.  
둘다 추상타입에 의존해야한다.  
실제 사용관계는 바뀌지 않으나 관계를 최대한 느슨하게 만드는것이 목적이다. (유연함)  
클래스와 클래스는 밀접한 관계를 맺고 있으면안된다.  
DI패턴을 구현하기위해서 인터페이스를 통해서 상속을 받는다.  
클래스와 클래스 사이에 인터페이스가 끼어들어야한다.  
연결된 클래스가 수정되어도 직접적인 오류가 나지 않는다.  
상위 클래스인 인퍼터페이스를 매개체로 연결되어있기 때문이다.  




## REF
- [1](https://velog.io/@cyranocoding/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DOOP-Object-Oriented-Programming-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC-igjyooyc6c)