
# 스프링(Spring)
- 프로젝트의 표준안을 제공함.
- 전자정부 프레임워크로 Spring을 지정됐기 때문에 국가단위 프로젝트를 할때 사용됨.
- 유지보수에 용이하다. 어떤 회사 사람이 오든 같은방식으로 사용하기 때문에.
- 디버깅을 할때 stack of flow나 구글링을 통해서 오류를 해결하는 방법밖에 없다.
- 오류방식이 Fram이란 구조 속에 숨어있기때문에 직접적으로 알기 어렵기때문...



## 1.설치방법
1) 개발 툴
    - intelliJ + Plug_in
    - 이클립스 + Plug_in
    - STS (string의 옷을 입힌 eclipse라고 보면된다) 
        - 무거움... 
        - string.io에서 다운받자.
        - TC server라는 자체 내장 서버를 제공한다.
    

## 2. 특징
1) 참고 
    - 공식사이트
        - (string.io)
    - https://www.egovframe.go.kr/
        - 국내 전자정부 사이트, 때때로 무료교육도 시행하는데 굉장히 인기 있기때문에 신청을 서둘러야한다
    - 오픈 커뮤니티 
        - https://open.egovframe.go.kr/
        - 내가 만든 프로젝트가 규격에 맞는지 확인도 해준다

2) 전자정부 프레임 워크
    - 모든 개발 분야에서 사용할 수 있는 프레임 워크


3) EJB - Spring
    - 여러서버에 분산하여 bean을 사용한다.
    - 이런 방식을 사용할때는 굉장히 큰 규모의 프로젝트르 진행할때..
    - 굉장히 무겁고 복잡함....

4) 정의 
    - 엔터프라이즈 어플리케이션에서 필요로 하는 기능을 제공하는 프레임워크 

5) J2EE가 제공하는 다수의 기능을 제공한다.
    - SE : standard edition
    - EE : enterprise edition
    - ME : micro edition

6) 경량 프레임워크
    - EJB에 비하면 가볍다

7) IoC/DI (Inversion of Control / Dependency Injection) 
    - 제어의 역전/ 의존성 주입
    - 낮은 결합도, 높은 응집도를 구현

    **Ioc(Inversion of Control)**
    - 프로그램의 제어 흐름 구조가 바뀌는 것을 의미한다.
    - IoC에 의해 객체 제어 권한이 스프링 컨테이너에 있기 떄문에 스프링에서는 일반적인 흐름과 다리 객체의 생성시점과 사용시점이 다르다.
    - IoC를 사용하면 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아진다.
    - IoC를 구현하기 위한 기술중 하나가 DI이다.
    - 애플리케이션을 구성하는 객체 간의 느슨한 결합, 낮은 결합도를 유지.
    - 객체 생성을 자바코드로 직접 처리하는 것이 아니라 컨테이너가 대신 처리한다.
    - 객체와 객체 사이의 의존관계도 컨테이너가 처리한다.

    **DI (Dependency Injection)**
    - 컨테이너에 의해 객체를 생성후 생성자나 setter 메서드를 통해 객체를 주입한다.
    - 의존성 관계 : 객체와 객체의 결합 관계
    - 주입 : 외부에서 받는다는 뜻
    - 즉 외부에서 생성된 B를 A에 주입함으로써 A객체와 B객체의 의존 관계를 없앤다.
    - 이것이 의존성 주입니다.

    **의존성 주입의 방법**<br>
    1. XML을 통한 의존성 주입
        1) 생성자를 통한 의존성 주입
            생성자에 인자를 주입하고자 하는 객체를 넣어준다.
            스프링 설정 파일에서는 <contructor-arg>태그와 ref속성을 이용한다.

        2) 속성을 통한 의존성 주입
            내부적으로 set method를 사용한다. 스프링 설정파일에서는 <property>태그를 사용해야 한다.
            name 속성값이 호출하고자 하는 메소드의 이름이어야한다.
            name에는 변수명을 적어주면 스프리에서 name의 첫 글자를 대문자로 바꾸고 앞에 set키워드를 붙여 setmethod 실행

    2. 어노테이션을 통한 주입<br>
    스프링에서는 @Autowired라는 어노테이션을 통해 의존성을 주입한다. <br>
    @Autowired는 속성의 설정자 메서드에 해당하는 역할을 자동으로 수행한다.
    자바 어노테이션으로는 @Resourece 어노테이션이 있다.<br>
    이 두 어노테이션의 차이는 bean을 탐색할 떄 우선순의로 하는 기준이 어떤 것이냐 하는 점이다.

8) AOP (Aspect Oriented Programming)

    1) 설명<br>
    기존의 비지니스 로직 외 작성해야 하는 코드를 별도로 분리함으로써 개발자가 좀 더 비지니스로직에만 집중하여 처리할 수 있는 방법을 제공한다.
    예를 들어 쇼핑몰을 구현할 때 핵심적인 비지니스로직은 구매, 장바구니, 구매 목록 조회 같은 기능이지만 이 모든것은 로그인 기능이 전제되어야 한다.
    따라서 로그인 기능과 핵심 기능을 분리하여 개발자가 핵심기능에 몰두할 수 있게 하며 그 외의 부가적인 개발이나 영향을 미치는 객체로 부터
    결합도를 최소화 하는 것이다.


    2) 관점 지향 프로그래밍<br>
        - DI가 의존성에 대한 주입이라면 AOP는 로직 주입이라고 말 할 수 있다.
        - 횡단 관심사 : 프로그래밍에서 다수의 모듈에 공통적으로 나타나는 부분, 공통로직
        - 핵심 관심사 : 모듈 각각 고유한 로직.
        - 즉 각 모듈을 구성하고 있는 코드는 핵심 관심솨와 횡단관심사로 이루어진다.

        - 관심 분리(Separation of Concerns)<br>
            관심분리가 AOP의 핵심이다.
            모듈마다 중복되는 부분을 걷어내는 것이 주 목적이다.
            간단히 생각해서 모듈 내의 중복코드를 하나로 묶어내는 것이 핵심이라 볼 수 있다.

        - 관심지향 프로그래밍<br>
            비즈니스 모듈을 개발할 때, 횡단 관심사와 핵심관심사를 분리함으로써 응집도가 높은 프로그램을 지원한다.
    3) 방식
        1. XML을 이용한 AOP
        2. 어노테이션을 이용한 AOP<br>
            - @Aspect  : 클래스를 AOP에서 사용하겠다는 의미
            - @Before  : 대상 메서드 상행 전에 이 메서드를 실행하겠다는 의미


9) POJO (Plain Old Java Object)
	- 개발자가 직접 Servlet클래스를 작성하지 않고 POJO 만으로 웹 애플리케이션을 구축할 수 있다
	- Servlet 클래스를 이용해서 자바 웹 애플리케이션을 구축하려면 반드시 Servlet에서 요구하는 규칙에 맞게 클래스를 만들어야 실행할 수 있다.
	 하지만 스프링을 통해서라면 일반적인 자바 객체로 웹 애플리케이션을 구축할 수 있으며 비지니스 로직에 집중할 수 있게된다.
	- 스프링에서 Servlet클래스가 추상화되어 라이브러리로 들어가있으며 개발자는XML 또는 다른 설정을 통해서 Servlet을 이용할 수 있게 된다.


10) Transaction처리를 위한 일관성 있는 방법을 제공한다.
    - All or nothing(말던가 다하던가)
    - try{~~~} catch{ rollback(); commit();}
    - 데이터가 변질되면 안되는 중요한 처리.

11) 영속성(Data Persistence)과 관련된 다양한 API제공
    - DB에 연동해서 사용할 수 있는 함수를 제공한다.
    - 요즘 트랜드는 DB전용 프레임워크를 사요한다.
    - 이런 기능은 자체적인 테스트 정도로 사용한다.

12) 컨테이너
    - 특정 객체의 생성과 관리를 담당하며 객체 운용에 필요한 다양한 기능을 제공한다.
    - 애플리케이션 운용에 필요한 객체를 생성하고 객체간의 의존관계를 관리한다는 점에서 스프링도 일종의 컨테이너라고 할 수 있다.

    1) BeanFactory
        - 스프링 설정파일(applicatoinContext.xml)에 등록된 <bean>객체를 생성하고 관리하는 가장 기본적인 컨테이너 기능만을 제공한다.
        - lazy loading : 컨테이너가 구동될 때 객체를 생성하는 것이 아니라 클라이언트로 부터의 요청에 의해서만 객체를 생성한다

    2) ApplicationContext
        - BeanFactory를 확장한 컨테이너다
        - BeanFactory의 기능에서 트랜잭션 관리나 메시지 기반의 다국어 처리등 다양한 기능 지원
        - 즉시 로딩방식 : 컨테이너가 구동되는 시점에 <bean>에 등록되어 있는 클래스들을 객체화한다.
        - ex) GenericXmlApplicatoinContext

		- 스프링 컨테이너는 <bean> 저장소에 해당하는 XML 설정 파일을 참조하여 <bean>의 생명주기를 관리하고 여러 가지 서비스를 제공한다.

	
13. ETC

**FrontController**<br>
공통 개발에서 규격화된 코드를 작성할 수 있고, 공통된 코드를 각각의 컨트롤러가 아닌 frontController에서 한 번만 작업하면 되므로 개발시간을 크게 단축할 수 있다.


**Handler Mapping**<br>
사용자의 각각의 요청에 대한 URL을 비교해 등록된 URL고 일치하는 컨트롤러를 탐색 후 전달하며 컨트롤러는 이 요청을 처리한 후 데이터를 사용자에게 뷰를 통하여 제공한다.

**Controller**<br>
전달된 요청을 처리하고 처리 후 결과 데이터를 요청에 맞는 뷰로 전달하는 역할
스프링 컨트롤러에서는 사용자의 요청에 필요한 데이터를 보다 쉽게 추출할 수 있고 추출하는 처리를 자동으로 해주기 떄문에 개발시간을 단축할 수 있다.
또한 기존의 XML파일을 통해 설정하는 것과 다르게 스프링에서는 애노테이션을 통해 간편하게 제어하므로 컨트롤러 설정이 간편하다.

**View Resolver**<br>
컨트롤러가 처리한 데이터를 각각의 해당하는 뷰에 매핑시켜주는 역할
스프링 컨트롤러는 view에 의전족이지않기 떄문에 컨트롤러는 뷰의 이름만 지정해주면 리졸버에서 해당하는 뷰 객체를 생성한다.
이렇게 생성된 뷰를 통해 사용자는 원하는 데이터를 받을 수 있다.


**PSA(Portable Service Abstraction)**<br>
- 일관성있는 서비스 추상화
- 서비스 추상화 : JDBC처럼 어댑터 패턴을 적용하여 같은 일을 하는 다수의 서비스를 공통의 인터페이스로 제어할 수 있게 한 것
- sts는 PSA를 위해 다양한 어댑터를 제공한다.
- OXM,ORM캐시,트랜잭션등 다양한 기술에 대한 PSA를 제공한다.




**Bean**
- 스프링 컨테이너에 의해 생성되고 제어되는 객체
- 스프링은 BeanFactory Object를 통해 싱글턴 패턴으로 빈을 생성하고 제어한다.
- 일반적으로 BeanFactory보다 이를 상속받은 ApplicationContext를 사용한다.
- ApplicationContext
 빈의 생성과 제어 뿐만 아니라 스프링에서 제공하는 어플리케이션 지원 기능을 모두 관리하는 의미한다.







**아키텍쳐 패턴**
	1. 아키텍쳐 
        - 소프트웨어 시스템을 구성하는 서브시스템과 컴포넌트 그리고 그것들의 관계를 나타내는 용어.
        - 컴포넌트로 구체화된 시스템의 기본적인 조직이며 호나경에 대한 관계이고 디자인과 진화를 이끄는 원리이다.
        - 프로그램을 구성하는 요소(서브시스템, 컴포넌트)와 그들 간의 관계를 나타낸다.
        건축할때 처럼 기초 토목 공사에서 건물의 외장까지 이르는 설계가 매우 중요한 것처럼
        프로그램을 제작할때, 시스템을 구성할때 소프트웨어 아키택처가 필요하다.
        프로그램이 점점 규모가 커져 복잡해지면 아치텍처의 존재는 불가결하다.

	2. 아키텍처 패턴
		- 특정 문제를 해결하기 위해 바녹되어 사용되는 솔루션을 문서화한 것
		- 소프트웨어 시스템의 구조를 체계적으로 구성하기 위한 기본적인 스키마를 제시
		- 미리 정의된 패턴간의 책임을 명시하여 규칙과 가이드라인을 제시한다.



## 3. 장단점
1) 이점
	- 일관성있는작업(협업에 편함)
	- 생산 효율성
2) 단점
	- 변화에 적응하기 힘들다.
	- 기술 진입장벽


## 4.스프링 동작원리
0. 클라이언트 요청
1. 웹 애플리케이션이 실행되면 was에 의해 web.xml이 로딩된다.
2. web.xml에 등록되어 있는 ContextLoaderListener가 생성된다. 
    ContextLoaderListener 클래스는 ServletContextLintener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.
3. 생성된 ContextLoaderListener는 root-context.xml을 로딩한다.
4. root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 개발자가 작성한 비지니스 로직에 대한 부분과 DAO, VO객체들이 생성된다.
5. 클라이언트로 부터 웹 애플리케이션이 요청이 온다.
6. DispatcherServlet이 생성된다. DispatcherServlet은 FrontController역할을 수행한다.
    클라이언트로부터 요청 온 메세지를 분석하여 알맞은 PageController에 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정한다.
    실질적인 작업은 PageController에서 이루어지기 때문이다. 이러한 클래스들은 HandlerMapping, ViewResolver 클래스라고 한다.
7. DispatcherServlet은 servlet-context.xml을 로딩한다.
8. 두번째 Spring Container가 구동되며 응답에 맞는 PageController들이 동작한다. 
    이 때 처선째 Spring Container가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.




    
### 전자정부 프레임워크
- Spring에서 정부에서 만든 plateform을 상속받아서 그 규격이 맞추어 만들었느냐 하는것....




## Spring project
- maven프로젝트를 기반으로 한다.	
- spring starter 프로젝트 
    - 스프링을 신속하게 시작할 수 있게 설정을 잡아준다.
    - 설정파일 생성및, 폴더 생성및 등등..

### www.spring.org
- spring boot

    스프링을 쉽게 시작할 수 있게 기반을 잡아준다.<br>
    이것을 기반으로 한 프로젝트가 spring starter프로젝트<br>
    스프링을 잘 모르는 사람들을 위한 기술.<br>
    대신에 기초설정및 cumstumizing을 하기 번거롭다.<br>

- spring legacy

    기초설정을 사용자가 셋팅해야한다.<br>
    선택할때 template을 mvc가 깔려있는 start legacy mvc 를 선택한다.<br>
    시작도메인에 페키지 이름을 정한다. com.yesman.팩키지명 <br>


