## 공통

### 본인의 직무를 정의한다면?
### 본인의 직무는 누구에게 어떠한 가치를 제공한다고 생각하나?
### 자신의 강점은 무엇이고, 단점을 보완하기 위해 어떠한 노력을 하고 있나?
### 함께 일했던 동료들에게 당신이 어떠한 사람인지 묻는다면 어떻게 답할 것 같나?
### OO 부서의 이직률이 매우 높은 편인데, 조직장으로서 이직률을 낮출 방법을 찾아야 한다면 어떤 것부터 시작하겠나?
### 펜션 시장 규모는 얼마이고, 여기어때의 점유율은 어느 정도인지 아는가?
### 동료와 관계에서 가장 큰 실패는 무엇이었나? 당신의 책임이 있었나?
### 가장 심각했던 갈등상황이 있었나? 어떻게 해결했나?
### 동료들로부터 인정이나 보상을 받은 경험이 있나?
### 어떠한 리더와 일하고 싶나? 그리고 어떠한 리더가 되고 싶나?
### 개발자로서의 본인의 비전을 이야기 해달라
### 왜 개발자가 되려고 하는가
### 프로젝트 협업 과정을 경험한 적이 있는가
### 최근에 관심갖거나 공부 하고 싶은 개발 기술은 무엇인가
### 개발자가 되기 위해서 어떻게 공부하였는가
### 학습시 주로 이용하는 웹페이지나, 동영상 강좌 페이지는 어디인가
### 최근의 읽은 개발 관련 서적은 무엇인가
### 비인기 라이브러리에 대한 정보를 어디서 얻는가 왜 활용하였는가

## skill
### 왜 SPA수요가 늘어났다고 생각하는가?
### react.js를 설명해보라.
### 최근 경험해 본 프론트엔트 프레임 웍은?
### 반응형 웹과 적응형 웹의 차이점은?
### api broken pipe 발생 원인과 해결 방법은 무엇일까?
### (웹)프론트엔드 개발자의 역할과 범위는?  

### Cross-Site Scripting (XSS)을 설명하고, 해결 방안은 무엇인지 말해보라. 
사이트에 스크립트코드를 삽입한 URL을 다른 사용자가 실행하도록 유도하여 정보를 빼내는 방법 
방어 방법으로 입력값 검증을 하거나 htmlentities을 사용해서 스크립트코드의 유입 경로를 차단하는 방법이 있다.


### CORS에 대해 설명할 수 있나?
다른 도메인의 정보를 요청하는 것을 말한다.  
이런 상황에서는 프록시서버를 두거나 서버에서 유효한 접근임을 확인하는 로직이 필요하다.

### http 프로토콜에서 https이미지를 불러올 수 있나? 불러온다면 어떠한 문제가 있을까. warning을 없앨 수 있는 방법은 무엇일까?
### SPA(Single Page Application)로 구성된 페이지에서 SEO(Search Engine Optimization)를 할 수 있는 방법은 무엇일까?
서버 사이드 랜더링을 통해 해결한다.

### SSR(Server Side Rendering)은 무엇이고 사용 목적은 무엇인가?
전통적인 웹과 달리 프론트 프레임워크를 이용한 SPA구조에서는 브라우저에서 랜더링을 수행한다.  
이를 client side rendering이라고 하는데 반대로 서버에서 html마크업을 작성하여 브라우저에 보내는 방식을
SSR이라고 한다.  

SPA환경에서 SSR을 지원하는 이유는 빠른 초기랜더링과 검색 엔진 최적화를 위해 사용한다.

### OOP에 특징에 대해 설명해달라
절차지향 프로그래밍의 단점을 극복하고자 나온 개발 방법으로 독립적인 기능을 수행하는 객체 단위로 개발한뒤 레고처럼 조립하여 프로그램을 완성하는 방법을 말합니다. 캡슐화, 다형성, 재상용성의 특징을 갖는 응집력 높은 코드를 작성할 수 있다.


### 브라우저 랜더링 과정 설명해보라

- html 파싱과정 
통신을 통해 문서의 내용을 받아 온뒤 
HTML 문서를 파싱하여 DOM tree를 만들고 병렬적으로 CSS 요소를 파싱하여 CSSOM를 만든다.  
Dom과 CSSOM를 기반으로 렌더트리를 생성한다. 이때 화면에 불필요한 노드들은 렌더트리에서 빠집니다.  
 각 노드가 화면의 정확한 위치에 표시되도록 레이아웃을 계산하고 
UI백엔드에서 렌더 트리의 각 노드를 그린다. 이 작업은 병렬적으로 이루어지는데 모든 HTML을 파싱하면서 배치와 페인트과정이 동시에 일어납니다. 


## CSS
- CSS float을 해제하지 않으면 안되는 이유
- IE에서 가장 좋아하는 기능은 무엇인가요?
- meta태그들



## JS

### 이벤트 위임에 대해 설명하세요.
### Promise란 무엇이며 코드가 어떻게 구성되어있는가
쉽게 말해 비동기 코드를 유연하게 사용하기 위한 패턴이다.  
기존 콜백패턴에서 콜백헬처럼 가독성과 재활용성이 떨어지게 되는데 promise도입으로 이런 문제를 해결했다. 

```js
function asyncFn (msg) {

    return new Promise(resolve, reject) {

        setTimeout(function(){
            resolve(msg)
        },1000)
    }
}

asyncFn('Hello').then((result)=>{
    console.log(result,"World")
})
```

### JavaScript로 컴파일되는 언어로 JavaScript 코드를 작성하는 경우의 장단점은 무엇인가요?
**장점**  
1. 정적타입 사용가능
2. 추가적인 기능을 제공받으면서 라이브러리를 사용하지않기 때문에 통일된 코드로 작성하면서 의존성을 극복할 수 있음
**단점**  
1. 템플릿 문법에 대한 러닝커브에 의한 생산성 하락
2. 서브파티 라이브러리와 호완성문제
3. IDE 지원이 미흡할 수 있음
4. 빌드 컴파일 프로세스를 위한 초기 작업 환경셋팅이 필요함

### Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라. 



**프로미스**  
1. 장점
- Promise.all()을 사용하여 병렬 비동기 코드를 쉽게 작성할 수 있습니다.
2. 딘점
- ES2015를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 합니다.

**콜백패턴**
1. 단점
-  콜백헬
```js
step1(function(value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        step5(value4, function(value5) {
            // value5를 사용하는 처리
        });
      });
    });
  });
});
```
- 에러 처리 한계
```js
try {
  setTimeout(() => { throw new Error('Error!'); }, 1000);
} catch (e) {
  console.log('에러를 캐치하지 못한다..');
  console.log(e);
}
```
예외는 호출스택을 따라 호출자에게 전파되는데 실행이 종료되어 호출스택에서 빠지면 에러를 전달하지 못한다.




### 클로저는 무엇이며, 어떻게 그리고 왜 사용하는지 설명해보라.
중첩함수 구조에서 외부함수가 외부함수의 로컬 변수를 참조하는 내부함수를 반환할 때,
외부함수의 Context varialbe object를 클로저라 부른다.  
execution contaxt에서 varialbe object는 arguments, variable, 함수 선언문으로 구성되는데 이 모두 클로저의 대상이다.  


호출이 끝난 context는 execution stack에서 사라진다.  
하지만 다른 context에서 해당 context의 variable object를 참조중이라면 해당 varible object는 garbage collection의 대상이 되지 않기때문에 계속 참조할 수 있다.  다시말해 스코프체인으로 참조중인 객체가 있다면 메모리에 유지되는것이다.

- [참고](https://medium.com/@pks2974/javascript-%EC%99%80-function-%ED%95%A8%EC%88%982-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-execution-context-51d4037b7fdc)
**이점**  
1. 모듈화
2. 재사용성 


### 실행 컨텍스트(Execution Context)에 대해 설명해달라  

코드가 실행되기 위한 환경으로 변수객체, 함수선언, 스코프, this로 구성된다.  

풀어서 말하자면 자바스크립트 엔진이 코드를 실행하기 위한 정보를 의미힌다. 즉 코드의 실행문맥이다.  
문맥에 따라 코드의 결과값이 달라진다. 그렇기에 코드의 문맥을 알고있어야 정확한 결과를 낼 수 있다.
자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 


**구성**  
1. Variable Object
    - variable: 로컬 지역변수
    - arguments:  
        - Functional Context 한정
    - 함수 선언문

2. Scope Chain  
스코프 체인은 실행 컨텍스트가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 리스트를 가르킨다.  
자바스크립트 엔진은 스코프 체인을 통해 렉시컬 스코프를 파악한다. 이 덕분에 상위 스코프를 참조할 수 있는 것이다.  
`[[Scopes]]` 으로 표현되며, 배열로 저장한다.

3. this value  
this 프로퍼티는 this 값이 할당되는데 할당되는 값은 런타임에 함수가 실행되는 5가지 경우의 컨텍스트에 따라 결정된다.
- global: 전역객체가 this
- functionInvocation: 
- call,apply,bind: 명시적 할당되는 객체가 this
- Construction: new에 의해 생성된 객체가 this
- MethodInvocation : 메소드를 포함하는 객체가 this.



**종류**  
- global context
- Functional Context
- eval 컨텍스트


- [참고](https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy)
- [참고2](https://m.blog.naver.com/PostView.nhn?blogId=gi_balja&logNo=221261731281&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

- [참고3](https://medium.com/@pks2974/javascript-%EC%99%80-function-%ED%95%A8%EC%88%982-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-execution-context-51d4037b7fdc)


### Class는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가?


### ajax란?
비동기 웹 응용 프로그램을 만들기 위해 클라이언트 측에서 사용되는 웹 개발 기술의 집합입니다. Ajax를 사용하면 웹 애플리케이션은 기존 페이지의 화면 및 동작을 방해하지 않으면서 백그라운드에서 비동기적으로 서버로 데이터를 보내고 서버에서 데이터를 받아올 수 있습니다. Ajax는 프리젠테이션 레이어에서 데이터 교환 레이어를 분리함으로써, 웹페이지 및 확장 웹 애플리케이션이 전체 페이지를 다시 로드 할 필요 없이 동적으로 컨텐츠를 변경할 수 있도록 합니다. 

### JSONP가 어떻게 동작하는지(그리고 Ajax와 어떻게 다른지)를 설명하세요.

### curry 함수의 예를 들어 줄 수 있나요? 그리고 이 문법은 어떤 이점을 가지고 있나요?
currying은 둘 이상의 매개 변수가 있는 함수가 여러 함수로 분리된 패턴으로, 직렬로 호출하면, 필요한 모든 매개 변수가 한 번에 하나씩 누적됩니다. 이 기법은 함수형 스타일로 작성된 코드를 읽고, 합성하기 더 쉬워진 경우 유용할 수 있습니다. 함수를 currying하려면, 하나의 함수로 시작하여, 하나의 매개 변수를 취하는 일련의 함수로 분리해야 합니다.


```js
function curry(fn) {
  if (fn.length === 0) {
    return fn
  }

  function _curried(depth, args) {
    return function(newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument)
      }
      return _curried(depth - 1, [...args, newArgument])
    }
  }

  return _curried(fn.length, [])
}

function add(a, b) {
  return a + b
}

var curriedAdd = curry(add)
var addFive = curriedAdd(5)

var result = [0, 1, 2, 3, 4, 5].map(addFive) // [5, 6, 7, 8, 9, 10]

```
### 생성자의 메서드에 화살표 문법을 사용하면 어떤 이점이 있나요?


### event bubbling에 대해 설명하세요.
DOM 요소에서 이벤트가 트리거되면 리스너가 연결되어 있는 경우 이벤트 처리를 시도한 다음, 해당 이벤트가 부모에게 bubbling되고 부모에서 같은 이벤트가 발생합니다. 
이 bubbling은 요소의 최상단 부모요소인 document까지 계속적으로 발생시킵니다. 이벤트 bubbling은 이벤트 위임의 작동 메커니즘입니다.


### ES6 클래스와 ES5 함수 생성자의 차이점은 무엇인가요?

### 호이스팅에 대해 설명하세요.

### 고차 함수(higher-order function)의 정의는 무엇인가요?
고차 함수는 다른 함수를 매개 변수로 사용하여 데이터를 처리하거나, 결과로 함수를 반환하는 함수입니다. 
고차 함수는 반복적으로 수행되는 어떤 연산을 추상화하기 위해 사용합니다. Array Api중 forEach, filter, reduce, map등이 있습니다
이중 map은 고차 함수를 사용하여 배열의 각 항목을 변환하고, 변환된 데이터로 새로운 배열을 반환합니다. 

### 자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라.
자바스크립트에서 this는 실행 컨텍스트가 생기는 시점에 할당된다

1. 생성자  
함수를 호출할 때 new 키워드를 사용하는 경우, 함수 내부에 있는 this는 완전히 새로운 객체입니다.
2. 명시적 할당  
apply, call, bind가 함수의 호출/생성에 사용되는 경우, 함수 내의 this는 인수로 전달된 객체입니다.
3. 메서드  
obj.method()와 같이 함수를 메서드로 호출하는 경우, this는 함수가 프로퍼티인 객체입니다.
4. 자유함수  
수가 자유함수로 호출되는 경우, 즉, 위의 조건 없이 호출되는 경우 this는 전역 객체입니다. 
브라우저에서는 window 객체입니다. 엄격 모드('use strict') 일 경우, this는 전역 객체 대신 undefined가 됩니다.

5. 화살표 함수
 화살표 함수인 경우 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 this값을 받습니다.


### 프로토타입이 어떻게 동작하는가?
 모든 JavaScript 객체는 다른 객체에 대한 참조인 prototype 프로퍼티를 가지고 있습니다. 객체의 프로퍼티에 접근할 때, 해당 객체에 해당 프로퍼티가 없으면 JavaScript 엔진은 객체의 prototype과 prototype의 prototype등을 보고 프로퍼티 정의가 있을 때까지 찾고, 만약 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 프로토타입 체인 중 하나에 있거나 프로토타입 체인의 끝에 도달할 때까지 찾습니다.

### JWT
- 왜 사용했는지
- 토큰과 쿠키/세션 차이
- JWT 토큰을 열어본 적 있는지


## 보안
### 보안은 서버쪽에서 많이 신경쓰고 있지만, 프론트엔드 개발에서 보안관련 이슈는 어떠한 것들이 있는가
1. XSS

### Wireshark에 대해 알고 있는가

### 간단한 데이터를 클라이언트로만 관리 할수 있는가, 이와 관련해서 브라우저 에서 어떠한 것들을 지원하고 있는가, 예를 들면 소셜 로그인같은 것들에 대한 브라우저 종료시 발생하는 문제에 대응 경험이 있는가? 
- localstorage
- indexDB






## React

### 서버 사이드와 프론트 사이드 로직을 나누는 기준은?
- 보안에 연결되는 비니니스 로직은 가능한 서버사이드에서 처리한다.
- 그밖에는 서버 통신 빈도를 줄이기 위해 프론트 사이드에서 구현한다.

즉 서버에서 간리해야하는 데이터와 프론트에서 관리해야하는 데이터를 구분해야한다.
프론트에서 관리하는 데이터는 주로 컴포넌트의 상태에 대한 데이터이고 
서버에서 다뤄야하는 데이터는 데이터베이스에 저장되는 데이터이다.  
데이터에 따라 이 데이터를 다루는 로직도 각각 프론트와 서버로 나뉜다.

### JSX란?
리액트에서 사용하는 마크다운 문법을 말한다.  리액트 엘리먼트를 쉽게 표현하기 위한 방법이다.  
JSX는 바벨등의 트랜스파일러를 이용해 js로 컴파일된다.
```jsx
const Hello = () => {
    return <p className='hello'>Hello world</p>
}
```

```js
const Hello = ( ) =>React.createElement(
    'p',
    { className: 'hello' },
    'Hello world'
)
```
JSX를 이용하면 리액트 컴포넌트를 이렇게 마크업 형식으로 표현할 수 있기 때문에 노드의 계층구조를 직관적으로 표현할 수 있다.
즉, JSX는 어디까지나 읽기 쉽고 작성하기 쉽도록 제공되는 Syntactic sugar이다.  

### react의 장점과 단점은?
**단점**  
- IE8이하 지원안함
- 개발횐경 직접 구성, 높은 자유도

### React.js 에서 DOM은 어느 시점에 생성되나?
1. 초기화  
    - componentWillMount와 componentDidMount사이에 
2. prop, state 변경  
    - componentWillUpdate와 componentWillUpdate 사이

### DOM이 뭔지 설명해 보라.
DOM(Document Object Model)은 웹 페이지에 대한 객체 모델 인터페이스입니다.  
현재 브라우저에 표시된 화면 정보를 객체 포멧으로 표현되어 있으며 DOM API를 통해 수정및 겁근이 가능합니다
[참고](https://wit.nts-corp.com/2019/02/14/5522)

### 가상돔(Virtual DOM) 개념은 무엇이며, DOM과의 차이점 가상돔의 개념이 사용되게된 배경은 무엇인가?
가상돔은 DOM 구조를 설명하는 자바스크립트 구조체이다.  
가상돔을 통한 DOM 조작의 이점은 렌더링 최적화를 라이브러리가 수행해준다는 것에 있다.  
바뀐 부분을 비교하여 찾아내서 기존 내용을 지우고 바뀐 부분을 한번에 랜더링하여 리플로와 리페인트 비용을 절약하는 것이 핵심이다.  


### state lifting이란?  
리액트 컴포넌트 트리에서 state를 분기가 되는 상위 컴포넌트로 올리는 것을 말한다.  
이로써 상태 전달 비용이 줄어든다. 

### 리덕스에 대해 설명
규모가 큰 리액트 애플리케이션에서 컴포넌트간 상태값 전달은 코드 복잡도, 유지보수성을 상승시킨다.  
상태관리 라이브러리인 리덕스는 단일 스토어에서 애플리케이션의 상태를 모두 관리하며 상태값 전달에 따른 컴포넌트간 결합도를 낮춘다. 각 컴포넌트는 스토어에 저장된 상태값을 읽고 업데이트함으로 컴포넌트간 직접 상태값을 주고받지 않아도 된다.  

**리덕스 장점**  
- 컴포넌트 코드에서 상태관리 코드를 분리할 수 있다.
- 서버 렌더링시 데이터 전달이 간편하다
- 로컬스토리지에 데이터를 저장하고 블러오는 코드를 쉽게 작성할 수 있다.
- 같은 상태값을 다수 컴포넌트에서 사용할 때 좋다.
- 부모 컴포넌트에서 깊은곳에 있는 자식 컴포넌트에 상태값을 전달할 때 좋음
- 알림창과 같은 전역 컴포넌트 상태값을 관리할 때 좋다.
- 페이지가 전환되어도 데이터가 살아있어야할때 좋음
- 사용자가 어떤 액션을 했고, 어떤 데이터가 어떻게 변경되었는지 쉽게 관찰할 수 있다.
- 모든 데이터는 스토리지에 저장할 수 있다. 사용자는 브라우저를 종료하고 다시 들어와도 완전 동일한 시점부터 다시 진행할 수 있다.  

### 상태관리 라이브러리가 불필요한 상황이 있다면?
리덕스를 사용하면 초기투자비용에 비유할 수 있는 코드가 발생한다.  코드량이 늘뿐만 아니라, 복잡도도 늘어난다.  
이런 부분은 상대적이기 때문에 애플리케이션의 구조에 따라서 도입여부를 결정해야한다.  

소규모의 단순한 프로젝트에서는 오히려 생산성을 떨어트릴 수 있다.

### MobX랑 리덕스 차이는 무엇인가?
### 리액트에서 arrow function을 사용하면 일반 함수를 쓰는 것과 어떤 차이가 있는지
### react를 사용하지 않는 사람에게 사용을 권유하며 설명해보라.
리액트는 사용자 인터렉션에 따른 돔 랜더링이 잦은 애플리케이션에 도입하면 도움이 되는 프론트 라이브러리입니다.  
직접 돔을 수정할 필요 없이 상태값에 따라 돔이 랜더링됨으로 로직이 단순해지고 개발자가 이를 신경쓰지 않아도 됩니다.  
또 가상돔을 이용한 돔 수정은 UI가 빈번하게 바뀌는 애플리케이션에서 랜더링 비용을 손쉽게 줄여줍니다.  

### 컴포넌트란?
사전적 의미로는 독립적 기능을 수행하는 구성요소.  
즉 프로그래밍에서 모듈이라 할 수 있다.  
리액트 컴포넌트란 화면을 구성하는 독립적인 모듈을 뜻한다. 즉 종속적이지 않기 때문에 모듈화 프로그래밍, UI 단위테스트, 테스트 자동화등이 가능하다.

### 리액트 훅에 대해 설명해보시오 + 이점
함수형 프로그래밍 지향에 따라 함수형 컴포넌트로 클래스 컴포넌트를 대체하기 위한 목적으로 도입되었다. 
함수형 컴포넌트에서 상태값 관리나 라이프 사이클 메서드를 사용하게 해주는 기능을 제공한다.  
[참고](https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks)

**이점**
1. 재사용성  
기존 라이프 사이클 메서드에 중복으로 사용하는 로직이 생겼는데 hook적용으로 로직 재사용이 가능해졌음
2. 가독성이 좋다   
기존 라이프사이클 메소드에 비해 가독성이 좋다.
3. 정접 타입을 적용하기 수월하다


### 리액트는 왜 함수형 프로그래밍을 지향하는가?
함수형 컴포넌트를 사용하면 컴포넌트를 간결하게 작성할 수 있으며, 개별 상태가 없으므로 이해하기 쉽고 예측이 쉬우며 테스트를 간단히 할 수 있다.  
또한 라이프사이클을 사용하지 않으므로 불필요한 검사 및 메모리 할당을 줄일 수 있다.  
따라서 React에서는 함수형 컴포넌트 컴포넌트를 많이 사용하고 클래스 컴포넌트는 적게 사용하는것을 권고한다.  
- 가독성
- 테스트
- 정적타입 적용 수월

### 서버 사이드랜더링이 필요한 이유는?
- 검색 엔진 최적화

### 16.8버전 이후 등장이후 고차 컴포넌트를 언제 사용하는가?
- DOM을 직접 조작하는 D3.js 같은 라이브러리와의 결합시에 예상되는 문제점이 있는가
- 리액트에서 이벤트 버블링에 대한 처리는 어떻게 다른가?
- 플럭스 아키텍쳐에 대해 설명해보라
- 리덕스와 어떻게 다른가?
- react 렌더링에 대한 이해
- 아토믹 디자인이란?
- 실무에서 컴포넌트 단위개발이 갖는 의미, 실제로 그렇게 개발하는지?
    - 아니라면 그 이유는?
    - 실무에서 타협점은?
- 빌드하는 이유가 뭐임?
- 프로젝트의 프론트엔드 성능을 개선하기 위해 어떤 방법을 사용했나요?
- 각 프로젝트별로 기술적으로 가장 어려웠던 점과 극복했던 방법을 한 가지씩만 얘기해보세요.

## network
- "RESTful 하다"라고 썼던데 그 말의 정확한 의미가 무엇인가요?

## test
- 테스트를 어떻게 하는지?

## etc
- 면접전에 지원회사의 서비스를 보고가야한다. 합류시 자사의 서비스 중 개선하고 싶은점과 서비스에 대해 평가를 해달라고 말하는 경우가 종종 있었다.
- 포트폴리오를 깃허브에 업로드시 코드가 허접하더라도 README.md를 자세히 작성하여야 한다
- 일부 회사 인터뷰 진행시, 채용과 별도로 면접관의 면접 경험을 위해 면접을 본다는 느낌을 받은 적이 있다
- 프론트엔드 커뮤니티에서 당신에게 영감을 준 사람이 있다면 누구인가요?





## resume
- https://github.com/rpf5573/about.me


## ref
- https://velog.io/@chris/front-end-interview-handbook-js-2
- https://velog.io/@chris/front-end-interview-handbook-js-3
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/FrontEnd
- https://taegon.kim/archives/5770
- https://blex.kr/@yoyounn18/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%A7%81%EA%B5%B0-%EC%9B%B9%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C-%EB%8B%B5%EB%B3%80-%EB%8B%AC%EC%95%84%EB%B3%B4%EA%B8%B0
- https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C

- https://velog.io/@tmmoond8/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-%ED%9B%84%EA%B8%B0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-%EC%9E%91%EC%84%B1-%EC%A4%91

- https://yoon.site/react-node-js-fullstack-%EA%B0%9C%EB%B0%9C%EC%A7%81%EA%B5%B0-%EB%A9%B4%EC%A0%91-%ED%9B%84%EA%B8%B0/

