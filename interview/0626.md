# 일반


##  본인의 성격
##  회사 서비스에 대해서, 회사가 어떤회사인지 아는가
- 자사 서비스에 대한 본인의 견해
- 자사 서비스에 대해서 얼마나 관심을 가지고 있는가 하는 질문
## 해당 공고 지원동기
- 우리 회사에 입사하고 싶은 이유
- 우리 회사에서 제공할 수 있는것.

##  이전 회사 퇴사 사유, 본인이 가장 중요시 하는것은?

##  전 직장에서 수행한 프로젝트 및 업무성과

## 채용과제를 진행하며 어려운 점이 없었는지?

## 이 라이브러리는 왜 썼는지?

## 다른 라이브러리를 고민하진 않았는지?

## 프로젝트 진행하면서 고민했던 부분과 개선사항에 대한 설명

## 서비스 문제해결 사례
- 어떤 문제가 있었고 어떻게 하기위해서 어떤 방법을 사용했는지?

## 업무 중에 동료에게 들었던 칭찬

## 최근 읽은 개발서적은?

## 프론트엔드 개발자로 일하려는 이유는?
## 가장 기억에 남는 프로젝트는?

# 기술


## 프론트엔드에서 관리하는 데이터와 서버에서 관리하는 데이터를 나누는 기준은?


## 이벤트 위임에 대해 설명하세요
이벤트 위임은 이벤트 리스터를 자식 요소에 추가하는 대신 부모요소에 추가하는 기법입니다.  
리스너는 이벤트 버블링으로 인해 자식요소에서 이벤트가 발생될 따마다 실행됩니다.  
- 각 자식 요소에 이벤트 핸들러를 바인딩하지 않고 부모요소 하나에 핸들러를 등록해서 메모리를 절약한다
- 제거된 요소에서 핸들러를 해제하거나 새 요소에 이벤트를 바인딩할 필요가 없다.


## this에 대해 설명하세요
1. 함수: 전역객체를 참조합니다.
2. apply, call, bind: 인수로 전달된 객체를 참조합니다.
3. 메서드: 메서드를 호출한 객체를 참조합니다.
4. 전역공간: 전역객체를 참조합니다.
5. strict mode: 이때는 전역공간에서 undefined가 됩니다.
6. 생성자 함수: 새롭게 생성한 인스턴스를 참조합니다.
7. 화살표 함수: 상위 스코프의 this를 참조합니다.

## 프로토타입 상속을 설명하세요
javascript 객체는 `__proto__`속성을 가지고 있습니다.  
객체의 프로퍼티에 접근할때 해당 프로퍼티가 없으면 `__proto__` 속성을 통해서 참조중인 객체를 탐색합니다. 
이 탐색 과정을 prototype chaine이라고 합니다.  
프로토 타입 상속은 `__proto__`속성으로 상위 객체의 속성과 메서드를 참조하는 것을 말합니다.  


## AMD vs CommonJS에 대해 어떻게 생각하나요?
- TODO

CommonJS
- 동기식
- 서버사이드 개발을 염두하고 설계
- 클라이언트 사이드와 서버사이드 JavaScript 개발 사이를 전환할 때 문맥 전환 오버 헤드가 적습니다.

AMD(Asynchronous Module Definition)
- 비동기식
- 모듈의 비동기 로딩을 지원하므로 브라우저용으로 더 많이 사용됩니다.

## 다음이 IIFE로 작동하지 않는 이유를 설명하세요: function foo(){ }();를 IIFE로 만들기 위해서는 무엇을 바꿔야하나요?
이것을 설명하기 위해선 식과 문을 구분해야합니다.  
우선 `function foo(){ }`는 함수 선언문이고 뒤에 오는 괄호`()`는 함수식을 호출할때 사용합니다.  
호출 연산자는 함수식과 함께 사용하기 때문에 함수 선언문을 함수식으로 만들어야합니다.  
이 함수 선언문을 ()로 묶으면 함수 식이 되고 `(function foo(){ })`, 이렇게 하면 다음 ()로 함수를 실행할 수 있습니다.  
이런 함수는 함수가 실행된 후 바로 소멸해버립니다.

```js
(function foo(){console.log('test')})();
foo();

//test
//Uncaught ReferenceError: foo is not defined
```


## 2. var, let/const 차이

1. var  
- var는 변수를 해당 실행스코프에 등록합니다. (함수스코프)
- 재할당이 가능합니다. 
- 재선언이 가능하다.
- TDZ이 발생하지 않습니다.

2. let
- 변수를 블록스코프에 등록합니다.
- 재선언이 불가능하다.
- 재할당이 가능합니다.
- TDZ이 발생합니다.

3. const
- 변수를 블록스코프에 등록합니다.
- 재선언이 불가능하다.
- 재할당이 불가능합니다.
- TDZ이 발생합니다.  


## null, undefined, undeclared의 차이점은 무엇인가요? 
1. null  
변수에 null이란 값을 할당했습니다. 명시적으로 아무것도 없음을 나타냅니다.

2. undefined  
- 선언되었지만, 값이 할당되지 않은 변수입니다.
- undefined 타입입니다

3. undeclared  
선언되지 않은 별수에 값을 할당할때 생성됩니다. .  
strict모드에서는 이런 경우 참조 오류(ReferenceError)가 납니다.  

```js
function foo() {
  x = 1; // strict 모드에서 ReferenceError를 발생시킵니다.
}

foo();
console.log(x); // 1
```

## 클로저란?
중첩함수 구조에서 내부함수가 참조하고 있는 렉시컬 스코프를 클로저를 의미합니다.  
내부함수를 반환하게 됐을때 외부함수의 스코프에 접근할 수 있고 외부함수를 즉시실행함수로 선언하게 될 경우 
외부함수의 실행컨텍스트는 내부함수의 렉시컬 스코프를 통해서만 접근가능하여 밀실화를 할 수 있습니다.

- 밀실화
- 모듈화

## .forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요? 
가장 큰 차이점은 반환값의 유무입니다.  
map은 배열 인덱스를 인수로 콜백을 실행하여 새로운 값을 반환합니다.  
배열에 새로운 값을 매핑하는 것입니다.  
이에 반해 forEach는 값을 반환하지 않으므로 단순 반복만 사용할때 사용하면 됩니다.  


## 익명함수의 사용례를 설명해달라.
익명함수는 개발자에 의해 직접 호출될 필요가 없는 곳에 사용한다.  
1. 즉시실행함수
```js
(function () {
  // 코드
})();
```
2. 콜백
```js
setTimeout(function () {
  console.log('Hello world!');
}, 1000);
```


## 호스트 객체와 내장객체의 차이가 무엇인가?
내장 객체는 ECMAScript 사양에 정의된 JavaScript 언어의 일부인 객체입니다. (예: String, Math, RegExp, Object, Function 등)
호스트 객체는 window, XMLHTTPRequest 등과 같이 런타임 환경 (브라우저 or 노드)에 의해 제공됩니다.  



## function Person(){}, var person = Person(), var person = new Person()의 차이점은 무엇인가요?

1. `function Person(){}`  
함수 선언

2. ` var person = Person()`
함수 호출

3. `var person = new Person()`  
함수를 생성자 함수로 호출, 프로토타입 체인에 의한 상속을 받는다.

## .call과 .apply의 차이점은 무엇인가요?
매개변수의 차이가 있습니다.  
call은 복수의 인자를 받고 apply는 배열을 두번자 인자로 받습니다.  
```js
function add(a, b) {
  return a + b;
}

console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```


## Function.prototype.bind란?
전달받은 객체를 this로 바인딩하여 새로운 함수를 반환합니다.  내부적으로 this를 래핑하는 함수가 구현되어 있습니다.  


## Ajax에 대해 가능한 한 자세히 설명하세요.
자바스크립트를 이용해 비동기로 리소스를 요청하는 웹 기술을 말합니다.  
Ajax를 사용하면 비동기로 데이터를 요청하기 때문에 동기식 데이터 요청시 화면 깜빡임문제가 사라지고 
자연스러운 동작이 가능하여 사용자 경험이 좋아집니다.  
코드적으로는 프리젠테이션 레이어와 데이터레이어를 분리할 수 있어 유지보수에 좋습니다.  

## AJax의 장단점.

**장점**  
1. 사용자 경험 향상
    - 화면 리프레시가 생기지 않기때문에 보다 자연스러운 서비스 제공가능
2. 통신비용 절감
    - 전체 페이지가 아닌 필요한 데이터만 요청하기 때문에 통신비용이 줄어든다
3. 웹페이지의 상태관리 가능
    - 페이지 리로드가 되지 않기때문에 상태를 관리가 가능하다. 


**단점**  
1. 검색엔진 최적화에 어려움이 생김
    - 로드되지 않은 콘텐츠가 존재하기 때문
2. 북마크가 어려움
    - 페이지 단위가 아니라 웹페이지의 상태를 통해 컨텐츠가 바뀌기 때문에 북마크가 어려울 수 있음.


## 호이스팅이란?
호이스팅은 블록 내에서 선언된 변수들을 스코프의 상단으로 옮기는 것을 말한다.  이런 특성때문에 
`var` 키워드나 함수 선언문으로 생성한 함수는 생성 시점보다 윗부분에서 접근이 가능합니다.  

## javascript의 내장객체를 확장하는 것의 문제점은 무엇일까요?
서드파티 라이브러리와 충돌가능성이 있습니다.  범용적으로 사용되는 내장객체를 수정하는 패턴은 코드의 안정성을 보장할 수 없습니다.  
내장객체를 확장하는 대신에 폴리필을 만드는 것이 낫습니다.  

## window.load와 document.DOMContentLoaded의 차이는?
1. window.load  
    - DOM과 모든 종속 리소스가 로드된 후 트리거 됩니다. 
2. DOMContentLoaded  
    - 리로스 로딩을 기다리지 않고 초기 HTML문서가 로드되고 파싱되면 트리거 됩니다.  

## Javascript관련하여 same-origin정책을 설명하세요  
- same-origin 정책은 javascript가 다른 도메인에 요청하는 것을 막습니다. origin은 URI 호스트 이름 포트의 조합으로 정의되며 이 정책은 한 페이지의 악의적인 스크립트가 해당 페이지의 돔을 통해 다른 웹페이지의 중요한 데이터에 접근하는 것을 막습니다.  


## strict모드에 대해서 설명해보세요
use strict는 전체 스크립트나 개별 함수에 엄격 모드를 사용하는데 사용되는 명령문입니다.

**장점**  
- 실수로 전역변수를 만드는것이 불가능하다. 
- 암묵적으로 실패한 예외를 throw하지 못하는 할당을 만든다.
- 함수의 매개변수 이름을 유일값이 되도록 제한한다. 
- this는 전역컨텍스트에서 undefined이다.


**단점**  
- 코드병합에 문제가 있을 수 있다. (엄격모드로 작성하지 않은 코드)
- function.caller와 function.arguments에 접근할 수 없다.



## single page app과 SEO를 지원하게 만드는 방법에 대해서 설명해보세요  
요즘엔 웹 사이트가 아닌 웹 앱을 제작하는 경우가 많습니다.  
웹앱은 동적이고 인터렉션이 잦은 웹입니다. 이런 웹앱을 전통적인 방식으로 서버에서 HTML을 받아서 렌더링하면 
새로고침으로 인한 깜빡임, 리소스 요청이 불필요하게 늘어나는 등의 문제때문에 사용자 경험이 떨어지빈다.(서버 사이드 렌더링)  

이런 이유로 등장한것이 SPA입니다. SPA에서는 클라이언트 사이드 렌더링을 하빈다. 브라우저는 애플리케이션에 필요한 스크립트 및 스타일시트를 초기 로딩 시점에 로드하빈다.  SPA는 초기 로딩때 마운트됨 javascript를 통해서 페이지를 동적으로 업데이트합니다.  

**장점**  
- 새로고침시 발생하는 깜빡임이 나타나지 않습니다.
- 서버에 대한 HTTP요청이 줄어듭니다.
- 일반적으로 SPA구조에서는 서버사이드와 독립적으로 구현되어 있어 서버코드를 다양한 플랫폼에서 사용하기 수월합니다.  

**단점**  
- 검색엔진 최적화가 어렵습니다.
    - 서버사이드 렌더링을 지원해야한다. 
- 초기로딩에 시간이 많이 걸립니다.

## 프로미스의 장단점
1. 콜백지옥을 해결합니다.
2. 프로미스 체인은 가독성이 좀더 좋고 연속적인 비동기 코드 작성이 수워합니다.  
3. 병렬 비동기 코드를 작성할 수 있습니다. (promise.all)
4. 예외처리가 수월합니다.

**단점**  
- 구형브라우저 지원을 위해 폴리필이 필요합니다.  



## "attribute"와 "property"의 차이점은 무엇인가요?
attribute는 HTML마크업에서 정의하며 property는 HTML을 파싱한 DOM에 정의됩니다.  



## Promise에 대해서 설명하고 예시를 들어봐라  
콜백 패턴의 문제를 보완할 수 있는 비동기 처리 패턴입니다.  
콜백패턴에는 콜백헬, 에러처리의 한계 등의 문제가 있습니다.  프로미스를 이용하면 이 단점을 해결할 수 있습니다.  

```js
const promise1 = function (param) {
  return new Promise (function (resolve, reject) {
    if (param) {
      resolve ("합격");
    }
    else {
      reject ("불합격");
    }
  });
}
//프로미스 실행
promise1(true).then(function(result) {
  console.log(result); // 합격
}, function(err) {
  console.log(err); // 불합격
});
```


콜백은 에러처리의 단점이 있습니다. 

```js
try {
  setTimeout(() => { throw 'Error!'; }, 1000);
} catch(e) {
  console.log('에러 캐치 불가능...');
  console.log(e);
}

```

promise에서는 이 단점을 보완합니다.  

```js
//프로미스 생성
const promise1 =  (param) => 
   new Promise (function (resolve, reject) {
    if (param) {
      resolve ("합격");
    }
    else {
      reject ("불합격");
    }
  });

promise1(null)
    .then(console.log)
    .catch(e=>{
        console.log(e)
    })
```



## DOM이란?
Document of Model의 약자.
브라우저는 HTML문서를 파싱해서 DOM객체를 만든다.  
개발자는 DOM을 통해서 문서를 동적으로 조작할 수 있다.  


## 브라우저 렌더링과정에 대해서 설명해봐라  
1. DOM 생성
2. CSSOM (CSS Object Model) 생성
3. Render Tree 생성
4. Layout:  Render Tree 배치
5. Rendering: Render Tree 그리기 이러한 과정을 통해 브라우저가 서버에 요청한 내용의 노드들을 픽셀화 시키는 것을 브라우저 렌더링 이라고 한다.


## 실행컨텍스트란?
자바스크립트 코드가 실행하기 위한 환경을 의미한다.  
함수가 실행될떄 마다 실행컨텍스트가 생성되는데 여기에는 생성당시 스코프, 매개변수, 내부변수 등의 정보가 기록된다.  
그리고 함수가 실행될때마다 함수의 실행컨텍스트를 참조하여 실행된다.  
함수가 실행될때 내부에서 사용되는 변수는 먼저 해당 함수의 실행컨스트를 참조하고 값을 찾지 못하면 스코프체인에 의해 상위 실행컨텍스트를 참조한다.   
최종적으로 함수 실행이 마무리 되면 해당 컨텍스트가 사라진다.  

## 이벤트 루프에 대해서 설명, 동시성 모델에 대해서 설명하라
싱글스레드 언어인 자바스크립트가 동시성을 제공하기 위해서는 프로세스를 비동기로 처리해야한다.  
그럼 비동기로 처리된 함수의 콜백함수가 실행될 타이밍을 제어할 필요가 있는데 그 일을 하는 것이 이벤트 루프이다.  
이벤트 루프는 호출스택을 감시하다가 호출스택이 비었을때 비동기 콜백이 쌓여있는 task que의 콜백함수를 호출스택으로 밀어넣는다  

이벤트 루프는 콜 스택을 모니터하고 태스크 큐에서 수행할 작업이 있는지 확인하는 단일 스레드 루프입니다.  
콜 스택이 비어 있고 태스크 큐에 콜백 함수가 있는 경우, 함수는 큐에서 제거되고 실행될 콜 스택으로 푸시됩니다.


## ES6 클래스와 ES5 함수 생성자의 차이점은 무엇인가요?

## 화살표함수를 언제 사용하나요?
현재 실행컨텍스트의 this를 유지하고 싶을 때 사용하면 유용합니다.  


## 생성자의 메서드에 화살표 함수를 사용했을때의 이점
- 함수 생성시 this의 값이 설정되고 그 이후에는 변경할 수 없다는 것입니다.

```js
const Person = function (firstName) {
  this.firstName = firstName;
  this.sayName1 = function () {
    console.log(this.firstName);
  };
  this.sayName2 = () => {
    console.log(this.firstName);
  };
};

const john = new Person('John');
const dave = new Person('Dave');

john.sayName1(); // John
john.sayName2(); // John

// 일반 함수의 'this'값은 변경할 수 있지만, 화살표 함수는 변경할 수 없습니다.
john.sayName1.call(dave); // Dave (because "this" is now the dave object)
john.sayName2.call(dave); // John

john.sayName1.apply(dave); // Dave (because 'this' is now the dave object)
john.sayName2.apply(dave); // John

john.sayName1.bind(dave)(); // Dave (because 'this' is now the dave object)
john.sayName2.bind(dave)(); // John

var sayNameFromWindow1 = john.sayName1;
sayNameFromWindow1(); // undefined (because 'this' is now the window object)

var sayNameFromWindow2 = john.sayName2;
sayNameFromWindow2(); // John
```

## 고차함수란??
함수를 인자로 받는 함수를 말합니다.  
이렇게 함으로써 반복되는 연산을 추상화할 수 있다.  map, filter, reduce등이 고차함수의 예이다.  


## curry함수란? 어떤 이점이 있는지?
둘 이상의 매개 변수가 있는 함수가 여러 함수로 분되는 패턴입니다.   
이 방식은 각각의 매개변수가 기록된 함수를 반환함으로써 함수 재사용성을 높혀줍니다.  


```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }

  function _curried(depth, args) {
    return function (newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument);
      }
      return _curried(depth - 1, [...args, newArgument]);
    };
  }

  return _curried(fn.length, []);
}

function add(a, b) {
  return a + b;
}

var curriedAdd = curry(add);
var addFive = curriedAdd(5);

var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

##  spread 문법을 사용할 때의 이점은 무엇이며 rest 문법과 다른 점은 무엇인가요?
spread문법은 불변성을 지키기위해서 새로운 객체를 반환할때 유용하게 사용할 수 있습니다.  
객체나 배열을 spread문법을 이용해 손쉽게 복사할 수 있습니다.  

```js
var ted = {
  name: 'Tad',
  age: 29,
};

var cloneTad = {...ted};
```
2. rest문법은 나열되는 값들중 일부만 명시적으로 사용하는 경우 유용하다.  
```js

const [a, b, ...rest] = [1, 2, 3, 4]; 
// a: 1, b: 2, rest: [3, 4]

const {e, f, ...others} = {
  e: 1,
  f: 2,
  g: 3,
  h: 4,
}; 
// e: 1, f: 2, others: { g: 3, h: 4 }
```

## static Member를 만드는 이유가 무엇인가요? 
static 멤버는 클래스의 특정 인스턴스와 독립적이며 항상 선언 당시의 값을 유지합니다.  
이는 인스턴스간 공통된 속성과 메서드를 선언했을때 메모리를 재사용하는 효과가 있습니다.  


##  비구조화 할당은 무엇인지? 예를 들어보세요
객체나 배열의 요소를 간단하게 변수에 할당하는 방법을 말합니다.  
이 기능을 통해 코드를 간결하게 만들 수 있습니다.  

```js
const ted = {
    name: 'ted',
    age: 29
}

const {name, age} = ted;
console.log(name, age)
```


## 스코프 체인에 대해서 설명해 달라
함수가 실행될 때 함수 선언문에 있는 변수를 렉시컬 스코프를 쫒아 탐색하는 것을 말한다.  

## 콜백함수에 대해 설명하라
어떤 함수의 실행이 종료된 뒤 에 실행하는 함수를 말한다.  
콜백함수는 비동기를 통해 동시성을 제공하는 자바스크립트에서 비동기적 로직을 연속적으로 사용하거나 후속처리를 하기 위해 필수적이다.  


## async awaite에 대해서 설명해 달라.
1. async  
- 함수 선언시 사용되는 키워드이며 해당 함수가 비동기 함수임을 나타내고 반환값으로 프로미스를 반환합니다.
- awaite키워드는 async함수에서 동작합니다.  

```js
async function foo(){
    return "test";
}

foo().then(console.log)
```

2. awiat
- 이 키워드는 프로미스를 suspend하는 키워드로 비동기로직을 동기적으로 동작하게 만들어 줍니다.  
- 이 키워드는 async함수 내부에서만 사용할 수 있습니다.  
- 이 키워드를 사용하면 promise의 resolve메서드의 인자가 반환값으로 반환됩니다.
```js

async function foo(){

    const re = await new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, "done!!")
    })
    console.log(re);
    console.log( "done after")
}

foo()
```



## 프로세스와 쓰레드의 차이는 무엇인지?
프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다.  
프로세스는 실행될 때 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받습니다. 스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행됩니다.  
 프로세스와 스레드에 대한 질문은 결국에는 운영체제가 시스템의 자원을 어떤 단위로 할당하고, 프로세스와 스레드는 이 자원을 어떻게 사용하느냐를 알고 있냐에 대한 질문입니다.  

 **멀티스레딩을 하는 이유**  
 운영체제는 시스템 자원을 효율적으로 관리하기 위해서 스레드를 사용하는 것이죠.  
 즉 멀티스레딩을 하는 이유는 자원 재활용을 위함이다. 
 - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.
 -  프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어들게 됩니다.
 - 스레드를 활용하면 자원의 효율성이 증가하기도 하지만 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야 합니다.
-  운영체제에서 작업을 실행할 때 자원을 할당하는 단위를 알고 있느냐와 프로그램을 멀티 스레드를 구현할 때 장.단점



1. 프로세스
- 프로세스는 메모리에 적재(load)되어 실행되고 있는 프로그램

- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
- 프로세스는 각각 독립적을 실행되어 다른 프로세스에 접근할 수 없다.  
    - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

- chrome 프로세스

프로그램과 프로세스의 관계
프로그램(메모장) 프로세스 내가 실행해서 메모리에 올라간 메모장
메모장을 여러개 킬 수 잇다는 것은 한 프로그램에서 실행되는 여러 프로세스가 동시에 존재할 수 있다는 것을 의미한다.



2. 스레드
- 프로세스 내에서 실행되는 흐름
- 프로세스 내에서 실행되는 여러 흐름의 단위
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.


## 객체지향과 함수형프로그래밍를 비교해서 말해보세요  



## 노드와 자바의 차이


## 이벤트 루프란 무엇인가요? 콜 스택과 태스크 큐의 차이점은 무엇인가요?


## REF
- [프론트엔드 면접 핸드북](https://github.com/yangshun/front-end-interview-handbook/blob/master/contents/kr/javascript-questions.md)
- [면접후기](https://velog.io/@denny6389/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EB%AC%B8%EC%A0%9C)