## 1. String Function

 - 1_1 CHR

 - 1_2 CONCAT 

 - 1_3 INITCAP 

 - 1_4 LOWER 

 - 1_5 LPAD 

 - 1_6 LTRIM 

 - 1_7 NLS_INITCAP 

 - 1_8 NLS_LOWER 

 - 1_9 NLSSORT 

 - 1_10 NLS_UPPER 

 - 1_11 REPLACE 

 - 1_12 RPAD 

 - 1_13 RTRIM 

 - 1_14 SOUNDEX 

 - 1_15 SUBSTR 

 - 1_16 TRANSLATE 

 - 1_17 TREAT 

 - 1_18 TRIM 

 - 1_19 UPPER 

 - 1_20 ASCII 

 - 1_21 INSTR 

 - 1_22 LENGTH 

 

## 2. datetime function

 - 2_1 ADD_MONTHS 

 - 2_2 CURRENT_DATE 

 - 2_3 URRENT_TIMESTAMP 

 - 2_4 DBTIMEZONE 

 - 2_5 EXTRACT(datetime )

 - 2_6 FROM_TZ 

 - 2_7 LAST_DAY 

 - 2_8 LOCALTIMESTAMP  

 - 2_9 MONTHS_BETWEEN 

 - 2_10 NEW_TIME 

 - 2_11 NEXT_DAY 

 - 2_12 NUMTODSINTERVAL 

 - 2_13 NUMTOYMINTERVAL 

 - 2_14 ROUND(date )

 - 2_15 SESSIONTIMEZONE 

 - 2_16 SYS_EXTRACT_UTC 

 - 2_17 SYSDATE 

 - 2_18 SYSTIMESTAMP 

 - 2_19 TO_DSINTERVAL 

 - 2_20 TO_TIMESTAMP 

 - 2_21 TO_TIMESTAMP_TZ 

 - 2_22 TO_YMINTERVAL 

 - 2_23 TRUNC(date 

 - 2_24 TZ_OFFSET 

 

## 3.conversion function

 - 3_1 ASCIISTR 

 - 3_2 BIN_TO_NUM 

 - 3_3 CAST 

 - 3_4 CHARTOROWID 

 - 3_5 COMPOSE  

 - 3_6 CONVERT 

 - 3_7 HEXTORAW 

 - 3_8 NUMTODSINTERVAL 

 - 3_9 NUMTOYMINTERVAL 

 - 3_10 RAWTOHEX 

 - 3_11 RAWTONHEX 

 - 3_12 ROWIDTOCHAR 

 - 3_13 ROWIDTONCHAR 

 - 3_14 TO_CHAR(character )

 - 3_15 TO_CLOB 

 - 3_16 TO_DSINTERVAL 

 - 3_17 TO_LOB 

 - 3_18 TO_MULTI_BYTE 

 - 3_19 TO_NCHAR(character )

 - 3_20 TO_NCHAR(datetime )

 - 3_21 TO_NCHAR(number )

 - 3_22 TO_NCLOB 

 - 3_23 TO_NUMBER 

 - 3_24 TO_SINGLE_BYTE 

 - 3_25 TO_YMINTERVAL 

 - 3_26 TRANSLATE ... USING 

 - 3_27 UNISTR 

 

## 4. miscellaneous single row function

 - 4_1 BFILENAME 

 - 4_2 COALESCE 

 - 4_3 DECODE 

 - 4_4 DEPTH 

 - 4_5 DUMP 

 - 4_6 EMPTY_BLOB 

 - 4_7 EMPTY_CLOB 

 - 4_8 EXISTSNODE 

 - 4_9 EXTRACT(XML 

 - 4_10 EXTRACTVALUE 

 - 4_11 GREATEST 

 - 4_12 LEAST 

 - 4_13 NLS_CHARSET_DECL_LEN 

 - 4_14 NLS_CHARSET_ID 

 - 4_15 NLS_CHARSET_NAME 

 - 4_16 NULLIF 

 - 4_17 NVL2 

 - 4_18 PATH 

 - 4_19 SYS_CONNECT_BY_PATH 

 - 4_20 SYS_CONTEXT 

 - 4_21 SYS_DBURIGEN 

 - 4_22 SYS_EXTRACT_UTC 

 - 4_23 SYS_GUID 

 - 4_24 SYS_XMLAGG 

 - 4_25 SYS_XMLGEN 

 - 4_26 UID 

 - 4_27 USER 

 - 4_28 USERENV 

 - 4_29 VSIZE 

 - 4_30 XMLAGG 

 - 4_31 XMLCOLATTVAL 

 - 4_32 XMLCONCAT 

 - 4_33 XMLFOREST 

 - 4_34 XMLELEMENT 

 

## 5.  Aggregate fuction

 - 5_1 AVG* 

 - 5_2 CORR* CORR* 

 - 5_3 COUNT* 

 - 5_4 COVAR_POP 

 - 5_5 COVAR_SAMP 

 - 5_6 CUME_DIST 

 - 5_7 DENSE_RANK 

 - 5_8 FIRST 

 - 5_9 GROUP_ID 

 - 5_10 Grouping 

 - 5_11 GROUPING_ID 

 - 5_12 LAST 

 - 5_13 MAX 

 - 5_14 MIN 

 - 5_15 PERCENTILE_CONT 

 - 5_16 PERCENTILE_DISC 

 - 5_17 PERCENT_RANK 

 - 5_18 RANK 

 - 5_19 REGR_(linear regression function* )

 - 5_20 STDDEV 

 - 5_21 STDDEV_POP 

 - 5_22 STDDEV_SAMP 

 - 5_23 SUM 

 - 5_24 VAR_POP 

 - 5_25 VAR_SAMP 

 - 5_26 VARIANCE 

 - 5_27 Grouping sets 

 

# 6. Analytic 

 - 6_1 AVG* 

 - 6_2 CORR* CORR* 

 - 6_3 COUNT* 

 - 6_4 COVAR_SAMP 

 - 6_5 CUME_DIST 

 - 6_6 DENSE_RANK 

 - 6_7 FIRST 

 - 6_8 FIRST_VALUE 

 - 6_9 LAG 

 - 6_10 LAST_VALUE 

 - 6_11 LEAD 

 - 6_12 NTILE 

 - 6_13 RATIO_TO_REPORT 

 - 6_14 ROW_NUMBER 

 

## 7. 객체 참조 함수

 - 7_1 REF 타입

 

## 8. PseudoColumn을 의미하는 것
 - 8_1 ROWID 컬럼
 - 8_2 ROWNUM 컬럼





#  functions
  1) single row functions
  -하나의 레코드에 대해서만 적용되는 함수.

		1. 문자함수
			- lower()
			- upper() 
			-  substr()  
			- lenggth() 
			- instr()  
			- ltrim()  
			- rtrim() 
			- translate() 
			
upper()

	ex) 이름이 scott인 직원의 이름, 부서, 급여를 조회.
	단, 대소문자 구별없이 검색할 수 있도록 한다.

~~~ 
  select ename,deptno, sal from emp where ename=upper('scott') ;
~~~ 
	
만약 데이터베이스에 저장된값이 대소문자가 섞여있다면..?
	
~~~   
select ename,deptno, sal from emp where upper(ename) = upper('scott');  
~~~ 





ex)  다음 주민번호에서 성별에 해당하는 것을 추출해라.
		'9012121010111'	//7번째 데이터
		
~~~ 
select substr('9012121010111',7,1)  from emp;		
//7번째 위치에서 1개뽑아내겠다.
~~~

select 기본문법상 테이블을 써줘야하는데... 
테이블과 상관없이 사용하때 
- 이런 테이블을 쓰세요 dual;
dual 테스트용으로 값을 하나만 뽑아내기 위해서 사용하는 가상테이블.

~~~ 
select substr('9012121010111',7,1)  from dual; 
select length('안녕하세요... sql입니다.')  from dual; 
~~~ 



	ex)  instr
	select instr('MiLLER','L')  FROM dual;
	select instr('MiLLER','K')  FROM dual;		//문자가 있는지 없는지 찾는목적
	select instr('MiLLER','L',1,2)  FROM dual;		//중복된값이 있다면 두번째값의 위치	
	select instr('MiLLER','L',4,1)  FROM dual;		//시작을 4번째부터.


	//3번째 찾을 데이터의 시작위치.
	 4번째 만약에 찾은 데이터가 2개 이상일때 몇번째 값을 조회할것인가?
	//sql에서는 숫자가 1부터 시작함.
	//해당문자가 있는지 없는지 찾아보기 위한 목적으로 많이 쓴다.
	



	ex)  문자나 공백 제거 하기
	ltrim() , rtrim() , trim() 
	select ltrim('MILLER','M')  from dual;
	select ltrim('MILLER','d')  from dual;		//안된다.
	select ltrim('  MILLER  ')  from dual;



ex)  문자열의 재배치

	-  translate 특정문자를 원하는 문자로 대치한다.

	select translate('MILLER','L','*') FROM dual;
	select replace('MILLER','L','*') FROM dual;


	select translate(sal, '0123456789','영일이삼사오육칠팔구')  from emp;
	//각각 자리에 맞추어서 바뀌어짐.
	//번역의 의미 값을 하나하나따지면서 2번째인자와 3번째 인자의 수가 같아서 매칭되어야한다.


	select replace(sal, '0123456789','영일이삼사오육칠팔구')  from emp;
	//인자를 통째로 덩어리로 인식한다.
	//얘는 안바뀌네..?


	select replace('JACK and JUE', 'J','BL')  from emp;
	select translate('JACK and JUE', 'J','BL')  from emp;
	//translate는 매칭이 되어야한다그래서 j와 매칭되는 b만 바뀌었다.) 


- .아스키코드 변환
	select chr(65) , chr(97)  from dual;
	select ascii('a') , ascii('A')  from dual;






  # 숫자함수
	- round() 
    - trunc() 
    - floor() 
    - ceil() 
	- mod() 
	- power() 
	- sign() 
	
	-------------------------------------------------------------
	- 소숫점 자리수
	 round() 
	~~~
	 select round(4567.678,0)  from dual;
	~~~
	- 자릿수(두번째 인자) 를 생략하면 소숫점 첫번째 자리를 반올림한다.
~~~
//세번째 자리에서 반올림하겠다는것.
select round(4567.678,2)  from dual;		-
//정수방향 반올림.  
select round(4567.678,-2)  from dual;
//버림!
select trunc(4567.678)  from dual;			
select trunc(4567.678,2)  from dual;
//무조건 내림
select floor(4567.678)  from dual;			
//무조건 올린다.
select cell(4567.678)  from dual;			
~~~

~~~
//나머지 연산
select mod(10,3)  from dual;		
//2^10;
select power(2,10)  from dual;		
//양수1 음수-1 영 0
select sign(100) ,sign(-15)  from dual;	
~~~





  ### 날짜함수
		- sysdate			//현재 시간을 알려준다.
		- months_between() 	
		- add_months() 		
		- next_day() 
		- last_day() 
		- round() 
		- trunc() 
----------------------------------
~~~
//현재날짜
select sysdate From dual;				

//N일 후
select sysdate +100 from dual;			

//날짜간격
select months_between(sysdate, '2017/2/20')  from dual;	

//N달 후
select add_months(sysdate, 21)  from dual;	

//돌아오는 요일
select next_day('2017/1/8','금') from dual; 		

//이달 마지막날.
select last_day(sysdate)  from dual;		

//오늘하루의 반 12시간이 지나서 4/5이 출력되었음.
select round(sysdate)  from dual;			

//날짜형식은 상관없는데 문자열이라서 컴파일오류
select round('2017/04/08')  from dual;			

//그대로 17/04/08출력됨.
select round(to_date('2017/04/08') )  from dual;	

//월을 기준으로 반올림한다는것.
select round(to_date('2017/04/16') ,'MONTH')  from dual;	

select round(to_date('2017/07/16') ,'year')  from dual;

~~~



### 변환함수
- cast() 
- to_char() 
- to_date() 
- to_number() 
---------------------------------------------------------------
~~~
//문자로 캐스팅.
select ename, sal, to_char(sal)  from emp;
select ename, sal, to_char(sal, '$999,999') from emp;	
//이때 두번째 인자의 9는 단순히 형식적인 의미이다.
//이렇게 형식을 제공할 수 있다.
//현재 지역에 맞게 통화표시를 하고싶다면?(현재 운영체제를 바탕으로.) 

// L :  locate를 의미한다.(시스템 지역에 맞는값이 출력된다) 
select ename, sal, to_char(sal, 'L999,999') from emp;

//이때 시,분,초 등을 추가할때는 쌍따옴표를 사용한다.
select to_char(sysdate,'YYYY MM DD HH"시" MI"분" SS"초"')  from dual;
~~~

  ### 기타.
- nvl()  
- decode() 
-----------------------------------------------------------

	ex)  직원의 이름, 급여, 보너스, 총급여를 조회하세요.
~~~  
select ename, sal, comm, (sal+comm)  as Total from emp;
~~~ 
널값을 피하려면 어떻게 해야할까?
~~~
select ename, sal, comm, (sal+nvl(comm,0) )  as Total from emp;
~~~
-  nvl(변수,0) 
    - 해당변수값이 null일때 두번째 인자값으로 대치해라.

- decode()  
    - 자바의 스위치문과 비슷하다.
	- 무조건 '같다'라는 조건만 가능하다.
 

    ex) 현재 업무가 salesman 이면 영업이라고 출력하고 그렇지 않으면 일반이라고 출력.
~~~  
select ename, decode(job,'SALESMAN','영업','일반')   from emp;	
~~~ 





  2) aggregation function
- 다중행,집합함수
- 복수의 레코드에 적용한다.

- sum() 
- avg() 
- max() 
- min() 
- count() 

- having
~~~
group by 필드명[, 필드명, ...]		
//이곳에는 where 조건은 사용할수 없다.
//group by에서만 사용가능한 조건식이다.
having 조건식	
~~~


    ex) 업무가 세일즈맨인 직원들의 급여평균, 최고액, 최저액, 합계를 조회하라.

~~~  
select avg(sal) , max(sal) , min(sal)  from emp where job='SALESMAN';
~~~ 
	
	ex)  직원이 총 몇명인가?
~~~  
select empno from emp;
//원시적
~~~ 	

~~~  
select count(empno)  from emp; 
select count(comm)  from emp; 
//널값은 카운트에서 제외다.

select count(*) from emp; ~~~ 		
//가장 많이 나오는수로 카운트한다.. 애매할 수 있는 연산이다.


ex)  부서별로 급여평균, 최저급여, 최고급여, 급여합계를 조회한다.
- 몇개의 부서가 있을까...?

~~~  
select distinct deptno from emp;
 ~~~ 
//어떤 부서가 있는지 조회한다. 10,20,30이 있다.

~~~  
select avg(sal) , min(sal) , max(sal) , sum(sal)  from emp where deptno=10;
~~~ 
~~~  
select avg(sal) , min(sal) , max(sal) , sum(sal)  from emp where deptno=20;
~~~ 
~~~  
select avg(sal) , min(sal) , max(sal) , sum(sal)  from emp where deptno=30;
~~~ 
//각 부서별 급여평균, 최저급여 , 최고급여, 급여합계를 개별적으로 입력한다.


//쌈박하게 처리하기
~~~ 
select deptno, avg(sal) , min(sal) , max(sal) , sum(sal)  from emp group by deptno;
~~~ 
//select의 확장문법, 쌈박하네.



ex) 부서별 직원 수 조회.
~~~ 
select deptno, count(deptno)  from emp group by deptno;
~~~ 

~~~ 
select deptno, sum(sal) ,avg(sal)  from emp group by deptno;
~~~ 



ex) 부서별로 급여평균, 최고 급여를 조회하는데, 단 급여평균이 높은순으로 조회.
~~~  
select avg(sal) , max(sal)  from emp group by deptno order by avg(sal)  desc; 
~~~ 



ex) 전체 급여의 합계가 5000을 초과하는 업무에 대해 급여 합계를 조회
- 업무별로..

~~~ 
select job, sum(sal)  from emp where sum(sal)  >5000 group by job;
~~~ 
- 처리순서때문에 오류남.
- 먼저 그룹별로 묶은다음에 조건을 걸어야하는데.. where는 다되지만 group by 뒤에는 올수없다.
- 대신 having이 와야한다.

~~~
    select job, sum(sal)  from emp group by job having sum(sal) >5000;
~~~ 



ex) 전체 급여의 합계가 5000을 초과하는 업무에 대해 급여 합계를 조회
    (단 세일즈맨은 제외하시오) 

