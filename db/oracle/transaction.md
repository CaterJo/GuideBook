# Transaction
- 컴퓨터가 처리하는 작업의 단위.	
- 사용자 입장에서는 작업의 논리적 단위
- 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위.
- DB에 데이터를 저장하거나 삭제, 갱신할때 일어나는 변경의 단위
- 트랜잭션의 범위를 설정하여 Rollback이 발생하는 시점을 정할 수 있다.
- All or Nothing
- 작업의 완전성, 데이터의 정합성을 보장한다.
- 작업을 모두 처리하거나 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.



## Lock
잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.<br>
여기서 자원은 레코드나 테이블을 말한다.<br>
이와는 조금 다르게 트랜잭션은 꼭 어러개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미하는 개념은 아니다. <br>
트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.<br><br>


## 1. 특성 ACID
**원자성(Atomicity)**<br>
만일 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야한다.
<br>

**일관성(Consistency)**<br>
트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야한다.<br>

**고립성(Isolation)**<br>
각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야한다.<br>

**지속성(Durability)**<br>
트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터 베이스에 작업의 결과가 저장되어야한다.<br><br><br>


## 2.상태
![](/resource/img/db/transaction_states.png)<br><br>


**Active**<br>
트랜잭션의 활동상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.<br>

**Failed**<br>
트랜잭션 실패상태. 트랜잭션이 더이상 정상저긍로 진행 할 수 없는 상태.<br>

**Partial Committed**<br>
트랜잭션의 Commit 명령이 도착한 상태.<br>
트랜잭션의 commit 이전 SQL문이 수행되고 COMMIT만 남은 상태.<br>

**Committed**<br>
트랜잭션 완료상태 트랜잭션이 정상적으로 완료된 상태<br>

**Aborted**<br>
트랜잭션 취소 상태<br>
트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태.<br>


**Partial Committed와 Committed의 차이점**<br>
Commit 요청이 들어오면 상태는 Partial Commited 상태가 된다.<br>
이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고 만약 오류가 발생하면 Failed 상태가 된다. <br>
즉, Partial Commited는 Commit 요청이 들어왔을 때를 말하며, Commited는 Commit을 정상적으로 완료한 상태를 말한다.
<br><br><br>


## 3.주의사항
트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화해야한다. <br>
일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 (즉 트랜잭션의 범위가 클 때)
사용 가능한 여유 커넥의 개수는 줄어들게 된다. <br>
그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.
<br><br><br>



## 4. 관련 명령어
**commit**<br>
메모리에만 기록되었던것이 commit이 실행되면 일이 끝마쳐지고 파일에 기록된다
<br><br>
		
**rollback**<br>
- 처음으로 돌아갈수 있다. 어느 시점으로 갈수 있는지?) 
- 작업마다 bookmark를 하고 돌아가는 시점을 저장할수 있다, 아니면 무조건 초기화
- 보통 접속부터 트렌젝션 시작, 접속종료하면 트렌젝션 종료 
- commit이 실행되면 트랜젝션이 종료되고 새로운 트랜젝션을 시작한다. 이제 롤백할수 없다
<br><br>


**flashback**<br>
- 오라클 API
- 'flash_recovery_date'폴더에 저장된다.
- flashback table tblA to before drop;
<br>

**recyclebin**<br>
- show recyclebin  : 휴지통 보기
- purge recyclebin : 휴지통 비우기.
<br>

**DROP TABLE**<br>
- DROP 명령어로 지운 테이블은 휴지통에 들어간다. 복구할 수 있다.
- DB 전문가는 완전 삭제되어도 돌릴 수 있다.
- create로 만든건 rollback이 안 된다.(?)
<br><br><br>



## 5.동기화
- 동시접속으로 인해 값이 달라지는걸 막는다.
- 한번에 하나의 처리만 한다.(하나의 독립적인 처리만 한다.) 
- 시스템적 처리가 자동으로 이루어지기 때문에 작어자가 해야할건 없음
- 동기화의 가장높은등급은 조회도 한번에 한명씩만 가능함.
- 동시접속을 했을때 다른 사용자가 commit을 해야지 다른 사용자가 확인이 가능하다.
<br><br><br>



## 기타.
- 트랜잭션 로그
	- 작업내용을 기록하는것.

## 오라클에서의 데이터베이스 구성.
1. 데이터파일
	-  .dbf
2. 로그파일
	- .log	
	- 여기에 Transaction log가 기록된다 
	- DML만 기록이 된다(UPDATE, DELETE..) 
3. ORCL
	- 우리가 설치한 데이터베이스 
	- C:\app\student\oradata\orcl
	- .DBF,LOG가 있다.