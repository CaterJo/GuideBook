# Front-End Architecture



## 초창기 웹애플리케이션
초창기 웹은 HTML페이지를 연결해놓은 수준이었다. 당시 자바스크립트의 역할은 `form` 필드 유효성 검사와 이미지 롤오버 정도에 쓰였다. DOM 노드에 기본적인 기능을 부여할 뿐이었다.  

이러한 웹 페이지 구조는 새로운 브라우저의 등장과 기술발전으로 빠르게 바뀌기 시작했다. 브라우저가 늘어나면서 일관성 있는 웹 사이트를 전달하기는 더 힘들어졌다. 웹 표준이 없었기 때문에 브라우저마다 제각기 다른 동작을 했다. 이런 브라우저간 호완성을 보안하기위해 jQery같은 라이브러리를 사용하기 시작했다. 

2005년 웹 구조의 판도를 바꾸는 기술이 등장했다. 구글 맵스(ajax를 이용한 애플리케이션)이 나오면서 정적 웹이 동적웹으로 바뀌었다. 
ajax를 쓰면 서버에서 페이지를 완전히 재렌더링할 필요가 없었다. 그 대신 클라이언트 측 애플리케이션 서버 APi와 Rest 앤드포인트에 직접 데이터를 요청하고 DOM을 관리했다. 이 시점을 기점으로 웹에 대한 개념이 완전히 뒤바뀌었다.  
하지만 이때까지만 해도 웹 페이지에서 사용되는 자바스크립트 로직이 그 파일에 전부 작성되어있어 소스 관리와 메모리누수의 문제가 있었다. 
시행착오를 겪은 기업은 애플리케이션 구축 방법의 표준화 필요성을 느꼈고 일관성있는 API와 서버 아키텍쳐를 도입하여 개발과 유지비용을 절약했다. 더불어 기업은 자바스크립트 프레임워크에 대한 필요성을 느꼈다.  

최초의 자바스크립트 프레임워크인 `Ext JS`는 컴포넌트 생명주기라는 개념을 도입하여 메모리를 관리하고 컴포넌트와 DOM의 결합도를 낮추어 개발자가 기능 구현에 집중할 수 있게 했다.


## Intro MVC와 MVVC
애플리케이션 아키텍처는 실제 클래스와 프레임워크 코드로 애플리케이션에 구조와 일관성을 제공한다. 우수한 아ㅣ텍쳐를 구축하면 몇가지 중요한 혜택을 누릴 수 있다.
- 모든 애플리케이션이 동일하게 작동하므로 한 번만 배우면된다.
- 여러 앱이 어렵지 않게 코드를 공유한다.
- 개발자들이 서로 중복되고 상충되는 기능을 만들기 어려워진다.
이런 프레임워크의 장점은 대규모 애플리케이션에서 특히 중요하다.

애플리케이션 아키텍쳐 패턴은 여러 가지 있지만 가장 많이 사용되는것은 MVC와 MVVM이다. 이 차이를 이해하는것이 중요하기 때문에 지금부터 각각 알아보기로 하자.


## 1. MVC
애플리케이션의 사용자 인터페이스를 세 가지로 나눔으로써 기능에 따라 코드를 정리해 정보를 논리적으로 표시할 수 있다.
MVC의 핵심은 다음과 같다.

- Model : 애플리케이션에 사용되는 데이터의 일반적인 포맷이다. 비즈니스 규칙, 유효성 검사 논리, 그 밖의 다양한 기능을 포함할 수도 있다.
- View : 사용자에게 데이터를 나타낸다. 다수의 뷰는 같은 모델 데이터를 다양하게 표시할 수 있다.
- Controller : MVC 애플리케이션의 핵심이다. 애플리케이션의 이벤트를 리스닝해 모델과 뷰 사이의 명령을 위임한다.

MVC 구조에서 프로그램의 모든 객체는 모델, 뷰, 컨트롤러 중 하나 이어야한다. 사용자는 view와 인터렉션을 하고 view는 Model에 있는 데이터를 표시한다. controller는 이런 인터렉션을 감시하며 필요할 때 view와 controller를 업데이트해야한다.

업데이트 지시는 전적으로 컨트롤러 역할이기 떄문에 뷰와 모델은 서로를 인식하지 못한다. 뷰에는 비지니스로직이 가능한 적어야하고 모델은 데이터의 단순한 인터페이스다. 그 말은 MVC구조에서 애플리케이션 내에서 컨트롤러가 애플리케이션 논리를 거의 다 가지고 있다는 뜻이다. 
MVC 아키텍처의 최고 장점은 스파게티 코드로 가득한 파일이 나올리 없다는 것이다.ㅣ MVC는

*단점*  
- View와 Model사이의 의존성이 높다. View와 Model의 높은 의존성은 어플리케이션이 커질수록 구조를 복잡하게 만들고 유지보수하기 어렵게 만든다.

*특징*
Controller는 여러개의 View를 선택할 수 있는 1:N구조다.
Controller는 view를 선택할 뿐 직접 업데이트 하지 않습니다.

*장점*


*동작*
1. 사용자의 Action들이 Controller에 들어오게 됩니다.
2. Controller는 사용자의 Action를 확인하고 Model을 업데이트 합니다.
3. Controller는 Model을 나타내줄 View를 선택합니다.
4. View는 Model을 이용하여 화면ㅇ르 나타냅니다.



## 2. MVVM
MVVM은 Model + View + View Model을 합친 용어입니다. 


### 1.구조 
- Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분.
- View : 사용자에서 보여지는 UI부분.
- View Model : View를 표현하기 위해 만든 View를 위한 Model. View를 나타내 주기 위한 Model이자 View르 ㄹ나타내기 위한 데이터를 처리하는 부분다.


### 2. 동작
1. 사용자의 Action들은 View를통해 들어오게 됩니다.
2. View에 Action이 들어오면, Command패턴으로 View Model에 Action을 전달합니다.
3. View Model은 Model에게 데이터를 요청합니다.
4. Model은 View Model에게 요청받은 데이터를 응답합니다.
5. View Model은 응답 받은 데이터를 가공하여 저장합니다.
6. Viwe는 View Model과 Data Binding하여 화면을 나타냅니다.

### 3. 특징
MVVC팬턴은 Command패턴과 Data Binding 두 가지 패턴을 상요하여 구현되었습니다. 이 두가지 패턴을 이용하여 View와 View 사이의 의존성을 없앴습니다. View MOdel과 view는 1:n 관계입니다.


### 4. 장점
MVVM 패턴은 View와 Model 사이의 의존성이 없습니다. 또한 Command 패턴과 DataBinding을 사용하여 View와 View Model사이의 의존성 또한 없앤 디자인패턴입니다. 각각의 부분은 독립적이기 떄문에 모듈화 하여 개발할 수 있습니다.


## Flux

### 1.특징
Flux의 가장 큰 특징은 단방향 데이터 흐름이빈다. 데이터 흐름은 항상 Dispatcher에서 Store로, Store에서 View로 View는 Action을 통해서 다시 Dispatcher로 데이터가 흐르게 됩니다. 이런 단방향 데이터 흐름은 데이터 변화를 예측하기 쉽게 만듭니다.


### 2.구성
1. Dispatcher  
Dispatcher는 Flux의 모든 데이터 흐름을 관리하는 허브 역할을 하는 부분입니다. Action이 발생하명 Dispatcher로전달되는데 Dispatcher는 전달된 Action을 보고 등록된 콜백 함수를 실행하여 Store에 데이터를 전달합니다. Dispatcher는 전체 어플리케이션에서 한 개의 인스턴스를 사용합니다.

2. Store
어플리케이션의 모든 상태 변경은 Store에 의해 결정됩니다. Dispatcher로 부터 메시지를 수신 받기 위해서는 Dispatcher에 콜백 함수를 등록해야 합니다. 
Store가 변경되면 View에 변겨오디었다는 사실을 알려주게 됩니다. Store는 싱글톤으로 관리됩니다.

3. View
Flux의 View는 화면에 나타내는 것 뿐만 아니라, 자식 View로 데이터를 흘려 보내는 뷰 컨ㅁ트롤러의 역할도 함꼐 합니다.

4. Action
Dispatcher에서 콜백 함수가 실행되면 Store가 업데이트 되게 되는데, 이 콜백 함수를 실행 할 때 데이터가 담겨 있는 객체가 인수로 전달 되어야하니다. 이 전달되는 객체를 Action이라고 하는데, Actoin은 대채로 Action creater에서 만들어집니다.


## Ref
- [Flux](https://beomy.tistory.com/44)
- [  s](https://beomy.tistory.com/43)
- [Front-End Mvc](https://www.miraeweb.com/single-post/2016/11/17/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9B%B9%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EB%B9%84%EA%B5%90%EB%B6%84%EC%84%9D-MVC%EC%99%80-MVVM)